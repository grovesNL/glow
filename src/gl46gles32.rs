// file generated by `phosphorus-2.0.3`
// Args { xml: "./generated/gl.xml", api: "gl", name: "GL_VERSION_4_6", number: "4.6", ext: ["GL_ARB_base_instance", "GL_ARB_buffer_storage", "GL_ARB_compute_shader", "GL_ARB_copy_buffer", "GL_ARB_debug_output", "GL_ARB_draw_elements_base_vertex", "GL_ARB_draw_instanced", "GL_ARB_framebuffer_object", "GL_ARB_framebuffer_sRGB", "GL_ARB_instanced_arrays", "GL_ARB_parallel_shader_compile", "GL_ARB_program_interface_query", "GL_ARB_sampler_objects", "GL_ARB_sync", "GL_ARB_tessellation_shader", "GL_ARB_texture_filter_anisotropic", "GL_ARB_texture_storage", "GL_ARB_uniform_buffer_object", "GL_ARB_vertex_array_object", "GL_EXT_buffer_storage", "GL_EXT_draw_buffers2", "GL_EXT_texture_filter_anisotropic", "GL_KHR_debug", "GL_KHR_parallel_shader_compile", "GL_NV_copy_buffer"] }

//! Module for interfacing with `GL_VERSION_4_6`.
//! 
//! Before actually calling any GL function, you must first
//! load the GL function pointers using [`load_gl_functions`].
//! Always do this *after* your GL context has been created.
//! Function pointers are loaded into global atomic variables,
//! so all GL contexts across all threads must use compatible
//! pointers. In practice, if all contexts are created using the
//! same context creation parameters they will have compatible
//! function pointers.
//! 
//! On some platforms it's possible to load an extension function
//! without the extension being supported for your context.
//! Always check that your context supports an extension before
//! calling any extension function.
//! 
//! Calling any GL function that isn't loaded will cause a panic.
#![allow(clippy::upper_case_acronyms)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::too_many_arguments)]
pub type GLenum = u32;
pub type GLbitfield = u32;
#[cfg(any(target_os = "ios", target_os = "macos"))]
pub type GLhandleARB = *mut void;
#[cfg(not(any(target_os = "ios", target_os = "macos")))]
pub type GLhandleARB = GLuint;
pub type GLeglClientBufferEXT = *mut void;
pub type GLeglImageOES = *mut void;
pub type GLsync = *mut void;
pub type _cl_context = void;
pub type _cl_event = void;
pub type GLDEBUGPROC = Option<
  unsafe extern "system" fn(
    source: GLenum,
    type_: GLenum,
    id: GLuint,
    severity: GLenum,
    length: GLsizei,
    message: *const GLchar,
    userParam: *const void,
  ),
>;
pub type GLDEBUGPROCARB = GLDEBUGPROC;
pub type GLDEBUGPROCKHR = GLDEBUGPROC;
pub type GLDEBUGPROCAMD = Option<
  unsafe extern "system" fn(
    id: GLuint,
    category: GLenum,
    severity: GLenum,
    length: GLsizei,
    message: *const GLchar,
    userParam: *mut void,
  ),
>;
pub type GLVULKANPROCNV = Option<unsafe extern "system" fn()>;
pub type GLboolean = u32;
pub type GLbyte = i8;
pub type GLcharARB = u8;
pub type GLclampd = f64;
pub type GLclampf = f32;
pub type GLclampx = i32;
pub type GLdouble = f64;
pub type GLfixed = i32;
pub type GLfloat = f32;
pub type GLhalf = u16;
pub type GLhalfARB = u16;
pub type GLhalfNV = u16;
pub type GLint = i32;
pub type GLint64 = i64;
pub type GLint64EXT = i64;
pub type GLintptr = isize;
pub type GLintptrARB = isize;
pub type GLshort = i16;
pub type GLsizei = u32;
pub type GLsizeiptr = isize;
pub type GLsizeiptrARB = isize;
pub type GLubyte = u8;
pub type GLuint = u32;
pub type GLuint64 = u64;
pub type GLuint64EXT = u64;
pub type GLushort = u16;
pub type GLvdpauSurfaceNV = GLintptr;
pub type void = core::ffi::c_void;
pub type GLchar = u8;

pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D9;
pub const GL_ACTIVE_ATTRIBUTES: u32 = 0x8B89;
pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
pub const GL_ACTIVE_PROGRAM: u32 = 0x8259;
pub const GL_ACTIVE_RESOURCES: u32 = 0x92F5;
pub const GL_ACTIVE_SUBROUTINES: u32 = 0x8DE5;
pub const GL_ACTIVE_SUBROUTINE_MAX_LENGTH: u32 = 0x8E48;
pub const GL_ACTIVE_SUBROUTINE_UNIFORMS: u32 = 0x8DE6;
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: u32 = 0x8E47;
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: u32 = 0x8E49;
pub const GL_ACTIVE_TEXTURE: u32 = 0x84E0;
pub const GL_ACTIVE_UNIFORMS: u32 = 0x8B86;
pub const GL_ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
pub const GL_ACTIVE_VARIABLES: u32 = 0x9305;
pub const GL_ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
pub const GL_ALL_BARRIER_BITS: u32 = 0xFFFFFFFF;
pub const GL_ALL_SHADER_BITS: u32 = 0xFFFFFFFF;
pub const GL_ALPHA: u32 = 0x1906;
pub const GL_ALREADY_SIGNALED: u32 = 0x911A;
pub const GL_ALWAYS: u32 = 0x0207;
pub const GL_AND: u32 = 0x1501;
pub const GL_AND_INVERTED: u32 = 0x1504;
pub const GL_AND_REVERSE: u32 = 0x1502;
pub const GL_ANY_SAMPLES_PASSED: u32 = 0x8C2F;
pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
pub const GL_ARRAY_BUFFER: u32 = 0x8892;
pub const GL_ARRAY_BUFFER_BINDING: u32 = 0x8894;
pub const GL_ARRAY_SIZE: u32 = 0x92FB;
pub const GL_ARRAY_STRIDE: u32 = 0x92FE;
pub const GL_ATOMIC_COUNTER_BARRIER_BIT: u32 = 0x00001000;
pub const GL_ATOMIC_COUNTER_BUFFER: u32 = 0x92C0;
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: u32 = 0x92C5;
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: u32 = 0x92C6;
pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: u32 = 0x92C1;
pub const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: u32 = 0x92C4;
pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: u32 = 0x9301;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: u32 = 0x90ED;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x92CB;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x92CA;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: u32 = 0x92C8;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: u32 = 0x92C9;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: u32 = 0x92C7;
pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: u32 = 0x92C3;
pub const GL_ATOMIC_COUNTER_BUFFER_START: u32 = 0x92C2;
pub const GL_ATTACHED_SHADERS: u32 = 0x8B85;
pub const GL_AUTO_GENERATE_MIPMAP: u32 = 0x8295;
pub const GL_BACK: u32 = 0x0405;
pub const GL_BACK_LEFT: u32 = 0x0402;
pub const GL_BACK_RIGHT: u32 = 0x0403;
pub const GL_BGR: u32 = 0x80E0;
pub const GL_BGRA: u32 = 0x80E1;
pub const GL_BGRA_INTEGER: u32 = 0x8D9B;
pub const GL_BGR_INTEGER: u32 = 0x8D9A;
pub const GL_BLEND: u32 = 0x0BE2;
pub const GL_BLEND_COLOR: u32 = 0x8005;
pub const GL_BLEND_DST: u32 = 0x0BE0;
pub const GL_BLEND_DST_ALPHA: u32 = 0x80CA;
pub const GL_BLEND_DST_RGB: u32 = 0x80C8;
pub const GL_BLEND_EQUATION: u32 = 0x8009;
pub const GL_BLEND_EQUATION_ALPHA: u32 = 0x883D;
pub const GL_BLEND_EQUATION_RGB: u32 = 0x8009;
pub const GL_BLEND_SRC: u32 = 0x0BE1;
pub const GL_BLEND_SRC_ALPHA: u32 = 0x80CB;
pub const GL_BLEND_SRC_RGB: u32 = 0x80C9;
pub const GL_BLOCK_INDEX: u32 = 0x92FD;
pub const GL_BLUE: u32 = 0x1905;
pub const GL_BLUE_INTEGER: u32 = 0x8D96;
pub const GL_BOOL: u32 = 0x8B56;
pub const GL_BOOL_VEC2: u32 = 0x8B57;
pub const GL_BOOL_VEC3: u32 = 0x8B58;
pub const GL_BOOL_VEC4: u32 = 0x8B59;
pub const GL_BUFFER: u32 = 0x82E0;
pub const GL_BUFFER_ACCESS: u32 = 0x88BB;
pub const GL_BUFFER_ACCESS_FLAGS: u32 = 0x911F;
pub const GL_BUFFER_BINDING: u32 = 0x9302;
pub const GL_BUFFER_DATA_SIZE: u32 = 0x9303;
pub const GL_BUFFER_IMMUTABLE_STORAGE: u32 = 0x821F;
pub const GL_BUFFER_IMMUTABLE_STORAGE_EXT: u32 = 0x821F;
pub const GL_BUFFER_KHR: u32 = 0x82E0;
pub const GL_BUFFER_MAPPED: u32 = 0x88BC;
pub const GL_BUFFER_MAP_LENGTH: u32 = 0x9120;
pub const GL_BUFFER_MAP_OFFSET: u32 = 0x9121;
pub const GL_BUFFER_MAP_POINTER: u32 = 0x88BD;
pub const GL_BUFFER_SIZE: u32 = 0x8764;
pub const GL_BUFFER_STORAGE_FLAGS: u32 = 0x8220;
pub const GL_BUFFER_STORAGE_FLAGS_EXT: u32 = 0x8220;
pub const GL_BUFFER_UPDATE_BARRIER_BIT: u32 = 0x00000200;
pub const GL_BUFFER_USAGE: u32 = 0x8765;
pub const GL_BUFFER_VARIABLE: u32 = 0x92E5;
pub const GL_BYTE: u32 = 0x1400;
pub const GL_CAVEAT_SUPPORT: u32 = 0x82B8;
pub const GL_CCW: u32 = 0x0901;
pub const GL_CLAMP_READ_COLOR: u32 = 0x891C;
pub const GL_CLAMP_TO_BORDER: u32 = 0x812D;
pub const GL_CLAMP_TO_EDGE: u32 = 0x812F;
pub const GL_CLEAR: u32 = 0x1500;
pub const GL_CLEAR_BUFFER: u32 = 0x82B4;
pub const GL_CLEAR_TEXTURE: u32 = 0x9365;
pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: u32 = 0x00004000;
pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT: u32 = 0x00004000;
pub const GL_CLIENT_STORAGE_BIT: u32 = 0x0200;
pub const GL_CLIENT_STORAGE_BIT_EXT: u32 = 0x0200;
pub const GL_CLIPPING_INPUT_PRIMITIVES: u32 = 0x82F6;
pub const GL_CLIPPING_OUTPUT_PRIMITIVES: u32 = 0x82F7;
pub const GL_CLIP_DEPTH_MODE: u32 = 0x935D;
pub const GL_CLIP_DISTANCE0: u32 = 0x3000;
pub const GL_CLIP_DISTANCE1: u32 = 0x3001;
pub const GL_CLIP_DISTANCE2: u32 = 0x3002;
pub const GL_CLIP_DISTANCE3: u32 = 0x3003;
pub const GL_CLIP_DISTANCE4: u32 = 0x3004;
pub const GL_CLIP_DISTANCE5: u32 = 0x3005;
pub const GL_CLIP_DISTANCE6: u32 = 0x3006;
pub const GL_CLIP_DISTANCE7: u32 = 0x3007;
pub const GL_CLIP_ORIGIN: u32 = 0x935C;
pub const GL_COLOR: u32 = 0x1800;
pub const GL_COLOR_ATTACHMENT0: u32 = 0x8CE0;
pub const GL_COLOR_ATTACHMENT1: u32 = 0x8CE1;
pub const GL_COLOR_ATTACHMENT10: u32 = 0x8CEA;
pub const GL_COLOR_ATTACHMENT11: u32 = 0x8CEB;
pub const GL_COLOR_ATTACHMENT12: u32 = 0x8CEC;
pub const GL_COLOR_ATTACHMENT13: u32 = 0x8CED;
pub const GL_COLOR_ATTACHMENT14: u32 = 0x8CEE;
pub const GL_COLOR_ATTACHMENT15: u32 = 0x8CEF;
pub const GL_COLOR_ATTACHMENT16: u32 = 0x8CF0;
pub const GL_COLOR_ATTACHMENT17: u32 = 0x8CF1;
pub const GL_COLOR_ATTACHMENT18: u32 = 0x8CF2;
pub const GL_COLOR_ATTACHMENT19: u32 = 0x8CF3;
pub const GL_COLOR_ATTACHMENT2: u32 = 0x8CE2;
pub const GL_COLOR_ATTACHMENT20: u32 = 0x8CF4;
pub const GL_COLOR_ATTACHMENT21: u32 = 0x8CF5;
pub const GL_COLOR_ATTACHMENT22: u32 = 0x8CF6;
pub const GL_COLOR_ATTACHMENT23: u32 = 0x8CF7;
pub const GL_COLOR_ATTACHMENT24: u32 = 0x8CF8;
pub const GL_COLOR_ATTACHMENT25: u32 = 0x8CF9;
pub const GL_COLOR_ATTACHMENT26: u32 = 0x8CFA;
pub const GL_COLOR_ATTACHMENT27: u32 = 0x8CFB;
pub const GL_COLOR_ATTACHMENT28: u32 = 0x8CFC;
pub const GL_COLOR_ATTACHMENT29: u32 = 0x8CFD;
pub const GL_COLOR_ATTACHMENT3: u32 = 0x8CE3;
pub const GL_COLOR_ATTACHMENT30: u32 = 0x8CFE;
pub const GL_COLOR_ATTACHMENT31: u32 = 0x8CFF;
pub const GL_COLOR_ATTACHMENT4: u32 = 0x8CE4;
pub const GL_COLOR_ATTACHMENT5: u32 = 0x8CE5;
pub const GL_COLOR_ATTACHMENT6: u32 = 0x8CE6;
pub const GL_COLOR_ATTACHMENT7: u32 = 0x8CE7;
pub const GL_COLOR_ATTACHMENT8: u32 = 0x8CE8;
pub const GL_COLOR_ATTACHMENT9: u32 = 0x8CE9;
pub const GL_COLOR_BUFFER_BIT: u32 = 0x00004000;
pub const GL_COLOR_CLEAR_VALUE: u32 = 0x0C22;
pub const GL_COLOR_COMPONENTS: u32 = 0x8283;
pub const GL_COLOR_ENCODING: u32 = 0x8296;
pub const GL_COLOR_LOGIC_OP: u32 = 0x0BF2;
pub const GL_COLOR_RENDERABLE: u32 = 0x8286;
pub const GL_COLOR_WRITEMASK: u32 = 0x0C23;
pub const GL_COMMAND_BARRIER_BIT: u32 = 0x00000040;
pub const GL_COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
pub const GL_COMPATIBLE_SUBROUTINES: u32 = 0x8E4B;
pub const GL_COMPILE_STATUS: u32 = 0x8B81;
pub const GL_COMPLETION_STATUS_ARB: u32 = 0x91B1;
pub const GL_COMPLETION_STATUS_KHR: u32 = 0x91B1;
pub const GL_COMPRESSED_R11_EAC: u32 = 0x9270;
pub const GL_COMPRESSED_RED: u32 = 0x8225;
pub const GL_COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
pub const GL_COMPRESSED_RG: u32 = 0x8226;
pub const GL_COMPRESSED_RG11_EAC: u32 = 0x9272;
pub const GL_COMPRESSED_RGB: u32 = 0x84ED;
pub const GL_COMPRESSED_RGB8_ETC2: u32 = 0x9274;
pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
pub const GL_COMPRESSED_RGBA: u32 = 0x84EE;
pub const GL_COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
pub const GL_COMPRESSED_RGBA_BPTC_UNORM: u32 = 0x8E8C;
pub const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: u32 = 0x8E8E;
pub const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: u32 = 0x8E8F;
pub const GL_COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
pub const GL_COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
pub const GL_COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
pub const GL_COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
pub const GL_COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
pub const GL_COMPRESSED_SRGB: u32 = 0x8C48;
pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
pub const GL_COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
pub const GL_COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
pub const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: u32 = 0x8E8D;
pub const GL_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
pub const GL_COMPUTE_SHADER: u32 = 0x91B9;
pub const GL_COMPUTE_SHADER_BIT: u32 = 0x00000020;
pub const GL_COMPUTE_SHADER_INVOCATIONS: u32 = 0x82F5;
pub const GL_COMPUTE_SUBROUTINE: u32 = 0x92ED;
pub const GL_COMPUTE_SUBROUTINE_UNIFORM: u32 = 0x92F3;
pub const GL_COMPUTE_TEXTURE: u32 = 0x82A0;
pub const GL_COMPUTE_WORK_GROUP_SIZE: u32 = 0x8267;
pub const GL_CONDITION_SATISFIED: u32 = 0x911C;
pub const GL_CONSTANT_ALPHA: u32 = 0x8003;
pub const GL_CONSTANT_COLOR: u32 = 0x8001;
pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
pub const GL_CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
pub const GL_CONTEXT_FLAGS: u32 = 0x821E;
pub const GL_CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
pub const GL_CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
pub const GL_CONTEXT_FLAG_NO_ERROR_BIT: u32 = 0x00000008;
pub const GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: u32 = 0x00000004;
pub const GL_CONTEXT_LOST: u32 = 0x0507;
pub const GL_CONTEXT_PROFILE_MASK: u32 = 0x9126;
pub const GL_CONTEXT_RELEASE_BEHAVIOR: u32 = 0x82FB;
pub const GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: u32 = 0x82FC;
pub const GL_COPY: u32 = 0x1503;
pub const GL_COPY_INVERTED: u32 = 0x150C;
pub const GL_COPY_READ_BUFFER: u32 = 0x8F36;
pub const GL_COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
pub const GL_COPY_READ_BUFFER_NV: u32 = 0x8F36;
pub const GL_COPY_WRITE_BUFFER: u32 = 0x8F37;
pub const GL_COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
pub const GL_COPY_WRITE_BUFFER_NV: u32 = 0x8F37;
pub const GL_CULL_FACE: u32 = 0x0B44;
pub const GL_CULL_FACE_MODE: u32 = 0x0B45;
pub const GL_CURRENT_PROGRAM: u32 = 0x8B8D;
pub const GL_CURRENT_QUERY: u32 = 0x8865;
pub const GL_CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
pub const GL_CW: u32 = 0x0900;
pub const GL_DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
pub const GL_DEBUG_CALLBACK_FUNCTION_ARB: u32 = 0x8244;
pub const GL_DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
pub const GL_DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
pub const GL_DEBUG_CALLBACK_USER_PARAM_ARB: u32 = 0x8245;
pub const GL_DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
pub const GL_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
pub const GL_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
pub const GL_DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
pub const GL_DEBUG_LOGGED_MESSAGES_ARB: u32 = 0x9145;
pub const GL_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB: u32 = 0x8243;
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
pub const GL_DEBUG_OUTPUT: u32 = 0x92E0;
pub const GL_DEBUG_OUTPUT_KHR: u32 = 0x92E0;
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB: u32 = 0x8242;
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
pub const GL_DEBUG_SEVERITY_HIGH: u32 = 0x9146;
pub const GL_DEBUG_SEVERITY_HIGH_ARB: u32 = 0x9146;
pub const GL_DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
pub const GL_DEBUG_SEVERITY_LOW: u32 = 0x9148;
pub const GL_DEBUG_SEVERITY_LOW_ARB: u32 = 0x9148;
pub const GL_DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
pub const GL_DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
pub const GL_DEBUG_SEVERITY_MEDIUM_ARB: u32 = 0x9147;
pub const GL_DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
pub const GL_DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
pub const GL_DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
pub const GL_DEBUG_SOURCE_API: u32 = 0x8246;
pub const GL_DEBUG_SOURCE_API_ARB: u32 = 0x8246;
pub const GL_DEBUG_SOURCE_API_KHR: u32 = 0x8246;
pub const GL_DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
pub const GL_DEBUG_SOURCE_APPLICATION_ARB: u32 = 0x824A;
pub const GL_DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
pub const GL_DEBUG_SOURCE_OTHER: u32 = 0x824B;
pub const GL_DEBUG_SOURCE_OTHER_ARB: u32 = 0x824B;
pub const GL_DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
pub const GL_DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
pub const GL_DEBUG_SOURCE_SHADER_COMPILER_ARB: u32 = 0x8248;
pub const GL_DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
pub const GL_DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
pub const GL_DEBUG_SOURCE_THIRD_PARTY_ARB: u32 = 0x8249;
pub const GL_DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB: u32 = 0x8247;
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB: u32 = 0x824D;
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
pub const GL_DEBUG_TYPE_ERROR: u32 = 0x824C;
pub const GL_DEBUG_TYPE_ERROR_ARB: u32 = 0x824C;
pub const GL_DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
pub const GL_DEBUG_TYPE_MARKER: u32 = 0x8268;
pub const GL_DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
pub const GL_DEBUG_TYPE_OTHER: u32 = 0x8251;
pub const GL_DEBUG_TYPE_OTHER_ARB: u32 = 0x8251;
pub const GL_DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
pub const GL_DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
pub const GL_DEBUG_TYPE_PERFORMANCE_ARB: u32 = 0x8250;
pub const GL_DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
pub const GL_DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
pub const GL_DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
pub const GL_DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
pub const GL_DEBUG_TYPE_PORTABILITY_ARB: u32 = 0x824F;
pub const GL_DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
pub const GL_DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
pub const GL_DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB: u32 = 0x824E;
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
pub const GL_DECR: u32 = 0x1E03;
pub const GL_DECR_WRAP: u32 = 0x8508;
pub const GL_DELETE_STATUS: u32 = 0x8B80;
pub const GL_DEPTH: u32 = 0x1801;
pub const GL_DEPTH24_STENCIL8: u32 = 0x88F0;
pub const GL_DEPTH32F_STENCIL8: u32 = 0x8CAD;
pub const GL_DEPTH_ATTACHMENT: u32 = 0x8D00;
pub const GL_DEPTH_BUFFER_BIT: u32 = 0x00000100;
pub const GL_DEPTH_CLAMP: u32 = 0x864F;
pub const GL_DEPTH_CLEAR_VALUE: u32 = 0x0B73;
pub const GL_DEPTH_COMPONENT: u32 = 0x1902;
pub const GL_DEPTH_COMPONENT16: u32 = 0x81A5;
pub const GL_DEPTH_COMPONENT24: u32 = 0x81A6;
pub const GL_DEPTH_COMPONENT32: u32 = 0x81A7;
pub const GL_DEPTH_COMPONENT32F: u32 = 0x8CAC;
pub const GL_DEPTH_COMPONENTS: u32 = 0x8284;
pub const GL_DEPTH_FUNC: u32 = 0x0B74;
pub const GL_DEPTH_RANGE: u32 = 0x0B70;
pub const GL_DEPTH_RENDERABLE: u32 = 0x8287;
pub const GL_DEPTH_STENCIL: u32 = 0x84F9;
pub const GL_DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
pub const GL_DEPTH_STENCIL_TEXTURE_MODE: u32 = 0x90EA;
pub const GL_DEPTH_TEST: u32 = 0x0B71;
pub const GL_DEPTH_WRITEMASK: u32 = 0x0B72;
pub const GL_DISPATCH_INDIRECT_BUFFER: u32 = 0x90EE;
pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: u32 = 0x90EF;
pub const GL_DITHER: u32 = 0x0BD0;
pub const GL_DONT_CARE: u32 = 0x1100;
pub const GL_DOUBLE: u32 = 0x140A;
pub const GL_DOUBLEBUFFER: u32 = 0x0C32;
pub const GL_DOUBLE_MAT2: u32 = 0x8F46;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT2x3: u32 = 0x8F49;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT2x4: u32 = 0x8F4A;
pub const GL_DOUBLE_MAT3: u32 = 0x8F47;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT3x2: u32 = 0x8F4B;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT3x4: u32 = 0x8F4C;
pub const GL_DOUBLE_MAT4: u32 = 0x8F48;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT4x2: u32 = 0x8F4D;
#[allow(non_upper_case_globals)]
pub const GL_DOUBLE_MAT4x3: u32 = 0x8F4E;
pub const GL_DOUBLE_VEC2: u32 = 0x8FFC;
pub const GL_DOUBLE_VEC3: u32 = 0x8FFD;
pub const GL_DOUBLE_VEC4: u32 = 0x8FFE;
pub const GL_DRAW_BUFFER: u32 = 0x0C01;
pub const GL_DRAW_BUFFER0: u32 = 0x8825;
pub const GL_DRAW_BUFFER1: u32 = 0x8826;
pub const GL_DRAW_BUFFER10: u32 = 0x882F;
pub const GL_DRAW_BUFFER11: u32 = 0x8830;
pub const GL_DRAW_BUFFER12: u32 = 0x8831;
pub const GL_DRAW_BUFFER13: u32 = 0x8832;
pub const GL_DRAW_BUFFER14: u32 = 0x8833;
pub const GL_DRAW_BUFFER15: u32 = 0x8834;
pub const GL_DRAW_BUFFER2: u32 = 0x8827;
pub const GL_DRAW_BUFFER3: u32 = 0x8828;
pub const GL_DRAW_BUFFER4: u32 = 0x8829;
pub const GL_DRAW_BUFFER5: u32 = 0x882A;
pub const GL_DRAW_BUFFER6: u32 = 0x882B;
pub const GL_DRAW_BUFFER7: u32 = 0x882C;
pub const GL_DRAW_BUFFER8: u32 = 0x882D;
pub const GL_DRAW_BUFFER9: u32 = 0x882E;
pub const GL_DRAW_FRAMEBUFFER: u32 = 0x8CA9;
pub const GL_DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
pub const GL_DRAW_INDIRECT_BUFFER: u32 = 0x8F3F;
pub const GL_DRAW_INDIRECT_BUFFER_BINDING: u32 = 0x8F43;
pub const GL_DST_ALPHA: u32 = 0x0304;
pub const GL_DST_COLOR: u32 = 0x0306;
pub const GL_DYNAMIC_COPY: u32 = 0x88EA;
pub const GL_DYNAMIC_DRAW: u32 = 0x88E8;
pub const GL_DYNAMIC_READ: u32 = 0x88E9;
pub const GL_DYNAMIC_STORAGE_BIT: u32 = 0x0100;
pub const GL_DYNAMIC_STORAGE_BIT_EXT: u32 = 0x0100;
pub const GL_ELEMENT_ARRAY_BARRIER_BIT: u32 = 0x00000002;
pub const GL_ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
pub const GL_EQUAL: u32 = 0x0202;
pub const GL_EQUIV: u32 = 0x1509;
pub const GL_EXTENSIONS: u32 = 0x1F03;
pub const GL_FALSE: u32 = 0;
pub const GL_FASTEST: u32 = 0x1101;
pub const GL_FILL: u32 = 0x1B02;
pub const GL_FILTER: u32 = 0x829A;
pub const GL_FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
pub const GL_FIXED: u32 = 0x140C;
pub const GL_FIXED_ONLY: u32 = 0x891D;
pub const GL_FLOAT: u32 = 0x1406;
pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
pub const GL_FLOAT_MAT2: u32 = 0x8B5A;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT2x3: u32 = 0x8B65;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT2x4: u32 = 0x8B66;
pub const GL_FLOAT_MAT3: u32 = 0x8B5B;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT3x2: u32 = 0x8B67;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT3x4: u32 = 0x8B68;
pub const GL_FLOAT_MAT4: u32 = 0x8B5C;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT4x2: u32 = 0x8B69;
#[allow(non_upper_case_globals)]
pub const GL_FLOAT_MAT4x3: u32 = 0x8B6A;
pub const GL_FLOAT_VEC2: u32 = 0x8B50;
pub const GL_FLOAT_VEC3: u32 = 0x8B51;
pub const GL_FLOAT_VEC4: u32 = 0x8B52;
pub const GL_FRACTIONAL_EVEN: u32 = 0x8E7C;
pub const GL_FRACTIONAL_ODD: u32 = 0x8E7B;
pub const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: u32 = 0x8E5D;
pub const GL_FRAGMENT_SHADER: u32 = 0x8B30;
pub const GL_FRAGMENT_SHADER_BIT: u32 = 0x00000002;
pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
pub const GL_FRAGMENT_SHADER_INVOCATIONS: u32 = 0x82F4;
pub const GL_FRAGMENT_SUBROUTINE: u32 = 0x92EC;
pub const GL_FRAGMENT_SUBROUTINE_UNIFORM: u32 = 0x92F2;
pub const GL_FRAGMENT_TEXTURE: u32 = 0x829F;
pub const GL_FRAMEBUFFER: u32 = 0x8D40;
pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
pub const GL_FRAMEBUFFER_BARRIER_BIT: u32 = 0x00000400;
pub const GL_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
pub const GL_FRAMEBUFFER_BLEND: u32 = 0x828B;
pub const GL_FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
pub const GL_FRAMEBUFFER_DEFAULT: u32 = 0x8218;
pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: u32 = 0x9314;
pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: u32 = 0x9311;
pub const GL_FRAMEBUFFER_DEFAULT_LAYERS: u32 = 0x9312;
pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: u32 = 0x9313;
pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: u32 = 0x9310;
pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
pub const GL_FRAMEBUFFER_RENDERABLE: u32 = 0x8289;
pub const GL_FRAMEBUFFER_RENDERABLE_LAYERED: u32 = 0x828A;
pub const GL_FRAMEBUFFER_SRGB: u32 = 0x8DB9;
pub const GL_FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
pub const GL_FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
pub const GL_FRONT: u32 = 0x0404;
pub const GL_FRONT_AND_BACK: u32 = 0x0408;
pub const GL_FRONT_FACE: u32 = 0x0B46;
pub const GL_FRONT_LEFT: u32 = 0x0400;
pub const GL_FRONT_RIGHT: u32 = 0x0401;
pub const GL_FULL_SUPPORT: u32 = 0x82B7;
pub const GL_FUNC_ADD: u32 = 0x8006;
pub const GL_FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
pub const GL_FUNC_SUBTRACT: u32 = 0x800A;
pub const GL_GEOMETRY_INPUT_TYPE: u32 = 0x8917;
pub const GL_GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
pub const GL_GEOMETRY_SHADER: u32 = 0x8DD9;
pub const GL_GEOMETRY_SHADER_BIT: u32 = 0x00000004;
pub const GL_GEOMETRY_SHADER_INVOCATIONS: u32 = 0x887F;
pub const GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: u32 = 0x82F3;
pub const GL_GEOMETRY_SUBROUTINE: u32 = 0x92EB;
pub const GL_GEOMETRY_SUBROUTINE_UNIFORM: u32 = 0x92F1;
pub const GL_GEOMETRY_TEXTURE: u32 = 0x829E;
pub const GL_GEOMETRY_VERTICES_OUT: u32 = 0x8916;
pub const GL_GEQUAL: u32 = 0x0206;
pub const GL_GET_TEXTURE_IMAGE_FORMAT: u32 = 0x8291;
pub const GL_GET_TEXTURE_IMAGE_TYPE: u32 = 0x8292;
pub const GL_GREATER: u32 = 0x0204;
pub const GL_GREEN: u32 = 0x1904;
pub const GL_GREEN_INTEGER: u32 = 0x8D95;
pub const GL_GUILTY_CONTEXT_RESET: u32 = 0x8253;
pub const GL_HALF_FLOAT: u32 = 0x140B;
pub const GL_HIGH_FLOAT: u32 = 0x8DF2;
pub const GL_HIGH_INT: u32 = 0x8DF5;
pub const GL_IMAGE_1D: u32 = 0x904C;
pub const GL_IMAGE_1D_ARRAY: u32 = 0x9052;
pub const GL_IMAGE_2D: u32 = 0x904D;
pub const GL_IMAGE_2D_ARRAY: u32 = 0x9053;
pub const GL_IMAGE_2D_MULTISAMPLE: u32 = 0x9055;
pub const GL_IMAGE_2D_MULTISAMPLE_ARRAY: u32 = 0x9056;
pub const GL_IMAGE_2D_RECT: u32 = 0x904F;
pub const GL_IMAGE_3D: u32 = 0x904E;
pub const GL_IMAGE_BINDING_ACCESS: u32 = 0x8F3E;
pub const GL_IMAGE_BINDING_FORMAT: u32 = 0x906E;
pub const GL_IMAGE_BINDING_LAYER: u32 = 0x8F3D;
pub const GL_IMAGE_BINDING_LAYERED: u32 = 0x8F3C;
pub const GL_IMAGE_BINDING_LEVEL: u32 = 0x8F3B;
pub const GL_IMAGE_BINDING_NAME: u32 = 0x8F3A;
pub const GL_IMAGE_BUFFER: u32 = 0x9051;
pub const GL_IMAGE_CLASS_10_10_10_2: u32 = 0x82C3;
pub const GL_IMAGE_CLASS_11_11_10: u32 = 0x82C2;
pub const GL_IMAGE_CLASS_1_X_16: u32 = 0x82BE;
pub const GL_IMAGE_CLASS_1_X_32: u32 = 0x82BB;
pub const GL_IMAGE_CLASS_1_X_8: u32 = 0x82C1;
pub const GL_IMAGE_CLASS_2_X_16: u32 = 0x82BD;
pub const GL_IMAGE_CLASS_2_X_32: u32 = 0x82BA;
pub const GL_IMAGE_CLASS_2_X_8: u32 = 0x82C0;
pub const GL_IMAGE_CLASS_4_X_16: u32 = 0x82BC;
pub const GL_IMAGE_CLASS_4_X_32: u32 = 0x82B9;
pub const GL_IMAGE_CLASS_4_X_8: u32 = 0x82BF;
pub const GL_IMAGE_COMPATIBILITY_CLASS: u32 = 0x82A8;
pub const GL_IMAGE_CUBE: u32 = 0x9050;
pub const GL_IMAGE_CUBE_MAP_ARRAY: u32 = 0x9054;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: u32 = 0x90C9;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: u32 = 0x90C8;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: u32 = 0x90C7;
pub const GL_IMAGE_PIXEL_FORMAT: u32 = 0x82A9;
pub const GL_IMAGE_PIXEL_TYPE: u32 = 0x82AA;
pub const GL_IMAGE_TEXEL_SIZE: u32 = 0x82A7;
pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
pub const GL_INCR: u32 = 0x1E02;
pub const GL_INCR_WRAP: u32 = 0x8507;
pub const GL_INFO_LOG_LENGTH: u32 = 0x8B84;
pub const GL_INNOCENT_CONTEXT_RESET: u32 = 0x8254;
pub const GL_INT: u32 = 0x1404;
pub const GL_INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
pub const GL_INTERNALFORMAT_ALPHA_SIZE: u32 = 0x8274;
pub const GL_INTERNALFORMAT_ALPHA_TYPE: u32 = 0x827B;
pub const GL_INTERNALFORMAT_BLUE_SIZE: u32 = 0x8273;
pub const GL_INTERNALFORMAT_BLUE_TYPE: u32 = 0x827A;
pub const GL_INTERNALFORMAT_DEPTH_SIZE: u32 = 0x8275;
pub const GL_INTERNALFORMAT_DEPTH_TYPE: u32 = 0x827C;
pub const GL_INTERNALFORMAT_GREEN_SIZE: u32 = 0x8272;
pub const GL_INTERNALFORMAT_GREEN_TYPE: u32 = 0x8279;
pub const GL_INTERNALFORMAT_PREFERRED: u32 = 0x8270;
pub const GL_INTERNALFORMAT_RED_SIZE: u32 = 0x8271;
pub const GL_INTERNALFORMAT_RED_TYPE: u32 = 0x8278;
pub const GL_INTERNALFORMAT_SHARED_SIZE: u32 = 0x8277;
pub const GL_INTERNALFORMAT_STENCIL_SIZE: u32 = 0x8276;
pub const GL_INTERNALFORMAT_STENCIL_TYPE: u32 = 0x827D;
pub const GL_INTERNALFORMAT_SUPPORTED: u32 = 0x826F;
pub const GL_INT_2_10_10_10_REV: u32 = 0x8D9F;
pub const GL_INT_IMAGE_1D: u32 = 0x9057;
pub const GL_INT_IMAGE_1D_ARRAY: u32 = 0x905D;
pub const GL_INT_IMAGE_2D: u32 = 0x9058;
pub const GL_INT_IMAGE_2D_ARRAY: u32 = 0x905E;
pub const GL_INT_IMAGE_2D_MULTISAMPLE: u32 = 0x9060;
pub const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: u32 = 0x9061;
pub const GL_INT_IMAGE_2D_RECT: u32 = 0x905A;
pub const GL_INT_IMAGE_3D: u32 = 0x9059;
pub const GL_INT_IMAGE_BUFFER: u32 = 0x905C;
pub const GL_INT_IMAGE_CUBE: u32 = 0x905B;
pub const GL_INT_IMAGE_CUBE_MAP_ARRAY: u32 = 0x905F;
pub const GL_INT_SAMPLER_1D: u32 = 0x8DC9;
pub const GL_INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
pub const GL_INT_SAMPLER_2D: u32 = 0x8DCA;
pub const GL_INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
pub const GL_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
pub const GL_INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
pub const GL_INT_SAMPLER_3D: u32 = 0x8DCB;
pub const GL_INT_SAMPLER_BUFFER: u32 = 0x8DD0;
pub const GL_INT_SAMPLER_CUBE: u32 = 0x8DCC;
pub const GL_INT_SAMPLER_CUBE_MAP_ARRAY: u32 = 0x900E;
pub const GL_INT_VEC2: u32 = 0x8B53;
pub const GL_INT_VEC3: u32 = 0x8B54;
pub const GL_INT_VEC4: u32 = 0x8B55;
pub const GL_INVALID_ENUM: u32 = 0x0500;
pub const GL_INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
pub const GL_INVALID_INDEX: u32 = 0xFFFFFFFF;
pub const GL_INVALID_OPERATION: u32 = 0x0502;
pub const GL_INVALID_VALUE: u32 = 0x0501;
pub const GL_INVERT: u32 = 0x150A;
pub const GL_ISOLINES: u32 = 0x8E7A;
pub const GL_IS_PER_PATCH: u32 = 0x92E7;
pub const GL_IS_ROW_MAJOR: u32 = 0x9300;
pub const GL_KEEP: u32 = 0x1E00;
pub const GL_LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
pub const GL_LAYER_PROVOKING_VERTEX: u32 = 0x825E;
pub const GL_LEFT: u32 = 0x0406;
pub const GL_LEQUAL: u32 = 0x0203;
pub const GL_LESS: u32 = 0x0201;
pub const GL_LINE: u32 = 0x1B01;
pub const GL_LINEAR: u32 = 0x2601;
pub const GL_LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
pub const GL_LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
pub const GL_LINES: u32 = 0x0001;
pub const GL_LINES_ADJACENCY: u32 = 0x000A;
pub const GL_LINE_LOOP: u32 = 0x0002;
pub const GL_LINE_SMOOTH: u32 = 0x0B20;
pub const GL_LINE_SMOOTH_HINT: u32 = 0x0C52;
pub const GL_LINE_STRIP: u32 = 0x0003;
pub const GL_LINE_STRIP_ADJACENCY: u32 = 0x000B;
pub const GL_LINE_WIDTH: u32 = 0x0B21;
pub const GL_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
pub const GL_LINE_WIDTH_RANGE: u32 = 0x0B22;
pub const GL_LINK_STATUS: u32 = 0x8B82;
pub const GL_LOCATION: u32 = 0x930E;
pub const GL_LOCATION_COMPONENT: u32 = 0x934A;
pub const GL_LOCATION_INDEX: u32 = 0x930F;
pub const GL_LOGIC_OP_MODE: u32 = 0x0BF0;
pub const GL_LOSE_CONTEXT_ON_RESET: u32 = 0x8252;
pub const GL_LOWER_LEFT: u32 = 0x8CA1;
pub const GL_LOW_FLOAT: u32 = 0x8DF0;
pub const GL_LOW_INT: u32 = 0x8DF3;
pub const GL_MAJOR_VERSION: u32 = 0x821B;
pub const GL_MANUAL_GENERATE_MIPMAP: u32 = 0x8294;
pub const GL_MAP_COHERENT_BIT: u32 = 0x0080;
pub const GL_MAP_COHERENT_BIT_EXT: u32 = 0x0080;
pub const GL_MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
pub const GL_MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
pub const GL_MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
pub const GL_MAP_PERSISTENT_BIT: u32 = 0x0040;
pub const GL_MAP_PERSISTENT_BIT_EXT: u32 = 0x0040;
pub const GL_MAP_READ_BIT: u32 = 0x0001;
pub const GL_MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
pub const GL_MAP_WRITE_BIT: u32 = 0x0002;
pub const GL_MATRIX_STRIDE: u32 = 0x92FF;
pub const GL_MAX: u32 = 0x8008;
pub const GL_MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
pub const GL_MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: u32 = 0x92DC;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: u32 = 0x92D8;
pub const GL_MAX_CLIP_DISTANCES: u32 = 0x0D32;
pub const GL_MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
pub const GL_MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: u32 = 0x92D7;
pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D1;
pub const GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: u32 = 0x82FA;
pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: u32 = 0x8266;
pub const GL_MAX_COMBINED_DIMENSIONS: u32 = 0x8282;
pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: u32 = 0x90CF;
pub const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: u32 = 0x8F39;
pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: u32 = 0x8F39;
pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: u32 = 0x90DC;
pub const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: u32 = 0x8E1E;
pub const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: u32 = 0x8E1F;
pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: u32 = 0x8265;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: u32 = 0x8264;
pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: u32 = 0x91BD;
pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: u32 = 0x90DB;
pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: u32 = 0x8262;
pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: u32 = 0x91BC;
pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: u32 = 0x91BB;
pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: u32 = 0x8263;
pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: u32 = 0x91BE;
pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: u32 = 0x90EB;
pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: u32 = 0x91BF;
pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
pub const GL_MAX_CULL_DISTANCES: u32 = 0x82F9;
pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
pub const GL_MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
pub const GL_MAX_DEBUG_LOGGED_MESSAGES_ARB: u32 = 0x9144;
pub const GL_MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
pub const GL_MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
pub const GL_MAX_DEBUG_MESSAGE_LENGTH_ARB: u32 = 0x9143;
pub const GL_MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
pub const GL_MAX_DEPTH: u32 = 0x8280;
pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
pub const GL_MAX_DRAW_BUFFERS: u32 = 0x8824;
pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
pub const GL_MAX_ELEMENTS_INDICES: u32 = 0x80E9;
pub const GL_MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
pub const GL_MAX_ELEMENT_INDEX: u32 = 0x8D6B;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: u32 = 0x92D6;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: u32 = 0x92D0;
pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: u32 = 0x90CE;
pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
pub const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: u32 = 0x8E5C;
pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: u32 = 0x90DA;
pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
pub const GL_MAX_FRAMEBUFFER_HEIGHT: u32 = 0x9316;
pub const GL_MAX_FRAMEBUFFER_LAYERS: u32 = 0x9317;
pub const GL_MAX_FRAMEBUFFER_SAMPLES: u32 = 0x9318;
pub const GL_MAX_FRAMEBUFFER_WIDTH: u32 = 0x9315;
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTERS: u32 = 0x92D5;
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: u32 = 0x92CF;
pub const GL_MAX_GEOMETRY_IMAGE_UNIFORMS: u32 = 0x90CD;
pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
pub const GL_MAX_GEOMETRY_SHADER_INVOCATIONS: u32 = 0x8E5A;
pub const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: u32 = 0x90D7;
pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
pub const GL_MAX_HEIGHT: u32 = 0x827F;
pub const GL_MAX_IMAGE_SAMPLES: u32 = 0x906D;
pub const GL_MAX_IMAGE_UNITS: u32 = 0x8F38;
pub const GL_MAX_INTEGER_SAMPLES: u32 = 0x9110;
pub const GL_MAX_LABEL_LENGTH: u32 = 0x82E8;
pub const GL_MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
pub const GL_MAX_LAYERS: u32 = 0x8281;
pub const GL_MAX_NAME_LENGTH: u32 = 0x92F6;
pub const GL_MAX_NUM_ACTIVE_VARIABLES: u32 = 0x92F7;
pub const GL_MAX_NUM_COMPATIBLE_SUBROUTINES: u32 = 0x92F8;
pub const GL_MAX_PATCH_VERTICES: u32 = 0x8E7D;
pub const GL_MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: u32 = 0x8E5F;
pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
pub const GL_MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
pub const GL_MAX_SAMPLES: u32 = 0x8D57;
pub const GL_MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
pub const GL_MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
pub const GL_MAX_SHADER_COMPILER_THREADS_ARB: u32 = 0x91B0;
pub const GL_MAX_SHADER_COMPILER_THREADS_KHR: u32 = 0x91B0;
pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: u32 = 0x90DE;
pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: u32 = 0x90DD;
pub const GL_MAX_SUBROUTINES: u32 = 0x8DE7;
pub const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: u32 = 0x8DE8;
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: u32 = 0x92D3;
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: u32 = 0x92CD;
pub const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: u32 = 0x90CB;
pub const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: u32 = 0x886C;
pub const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: u32 = 0x8E83;
pub const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: u32 = 0x90D8;
pub const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: u32 = 0x8E81;
pub const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8E85;
pub const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: u32 = 0x8E89;
pub const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: u32 = 0x8E7F;
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: u32 = 0x92D4;
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: u32 = 0x92CE;
pub const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: u32 = 0x90CC;
pub const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: u32 = 0x886D;
pub const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: u32 = 0x8E86;
pub const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: u32 = 0x90D9;
pub const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: u32 = 0x8E82;
pub const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: u32 = 0x8E8A;
pub const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: u32 = 0x8E80;
pub const GL_MAX_TESS_GEN_LEVEL: u32 = 0x8E7E;
pub const GL_MAX_TESS_PATCH_COMPONENTS: u32 = 0x8E84;
pub const GL_MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
pub const GL_MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
pub const GL_MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: u32 = 0x84FF;
pub const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
pub const GL_MAX_TEXTURE_SIZE: u32 = 0x0D33;
pub const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: u32 = 0x8E70;
pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
pub const GL_MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
pub const GL_MAX_UNIFORM_LOCATIONS: u32 = 0x826E;
pub const GL_MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
pub const GL_MAX_VARYING_FLOATS: u32 = 0x8B4B;
pub const GL_MAX_VARYING_VECTORS: u32 = 0x8DFC;
pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: u32 = 0x92D2;
pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: u32 = 0x92CC;
pub const GL_MAX_VERTEX_ATTRIBS: u32 = 0x8869;
pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: u32 = 0x82DA;
pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: u32 = 0x82D9;
pub const GL_MAX_VERTEX_ATTRIB_STRIDE: u32 = 0x82E5;
pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: u32 = 0x90CA;
pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: u32 = 0x90D6;
pub const GL_MAX_VERTEX_STREAMS: u32 = 0x8E71;
pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
pub const GL_MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
pub const GL_MAX_VIEWPORTS: u32 = 0x825B;
pub const GL_MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
pub const GL_MAX_WIDTH: u32 = 0x827E;
pub const GL_MEDIUM_FLOAT: u32 = 0x8DF1;
pub const GL_MEDIUM_INT: u32 = 0x8DF4;
pub const GL_MIN: u32 = 0x8007;
pub const GL_MINOR_VERSION: u32 = 0x821C;
pub const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: u32 = 0x8E5B;
pub const GL_MIN_MAP_BUFFER_ALIGNMENT: u32 = 0x90BC;
pub const GL_MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: u32 = 0x8E5E;
pub const GL_MIN_SAMPLE_SHADING_VALUE: u32 = 0x8C37;
pub const GL_MIPMAP: u32 = 0x8293;
pub const GL_MIRRORED_REPEAT: u32 = 0x8370;
pub const GL_MIRROR_CLAMP_TO_EDGE: u32 = 0x8743;
pub const GL_MULTISAMPLE: u32 = 0x809D;
pub const GL_NAME_LENGTH: u32 = 0x92F9;
pub const GL_NAND: u32 = 0x150E;
pub const GL_NEAREST: u32 = 0x2600;
pub const GL_NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
pub const GL_NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
pub const GL_NEGATIVE_ONE_TO_ONE: u32 = 0x935E;
pub const GL_NEVER: u32 = 0x0200;
pub const GL_NICEST: u32 = 0x1102;
pub const GL_NONE: u32 = 0;
pub const GL_NOOP: u32 = 0x1505;
pub const GL_NOR: u32 = 0x1508;
pub const GL_NOTEQUAL: u32 = 0x0205;
pub const GL_NO_ERROR: u32 = 0;
pub const GL_NO_RESET_NOTIFICATION: u32 = 0x8261;
pub const GL_NUM_ACTIVE_VARIABLES: u32 = 0x9304;
pub const GL_NUM_COMPATIBLE_SUBROUTINES: u32 = 0x8E4A;
pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
pub const GL_NUM_EXTENSIONS: u32 = 0x821D;
pub const GL_NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
pub const GL_NUM_SAMPLE_COUNTS: u32 = 0x9380;
pub const GL_NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
pub const GL_NUM_SHADING_LANGUAGE_VERSIONS: u32 = 0x82E9;
pub const GL_NUM_SPIR_V_EXTENSIONS: u32 = 0x9554;
pub const GL_OBJECT_TYPE: u32 = 0x9112;
pub const GL_OFFSET: u32 = 0x92FC;
pub const GL_ONE: u32 = 1;
pub const GL_ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
pub const GL_ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
pub const GL_ONE_MINUS_DST_ALPHA: u32 = 0x0305;
pub const GL_ONE_MINUS_DST_COLOR: u32 = 0x0307;
pub const GL_ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
pub const GL_ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
pub const GL_ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
pub const GL_ONE_MINUS_SRC_COLOR: u32 = 0x0301;
pub const GL_OR: u32 = 0x1507;
pub const GL_OR_INVERTED: u32 = 0x150D;
pub const GL_OR_REVERSE: u32 = 0x150B;
pub const GL_OUT_OF_MEMORY: u32 = 0x0505;
pub const GL_PACK_ALIGNMENT: u32 = 0x0D05;
pub const GL_PACK_COMPRESSED_BLOCK_DEPTH: u32 = 0x912D;
pub const GL_PACK_COMPRESSED_BLOCK_HEIGHT: u32 = 0x912C;
pub const GL_PACK_COMPRESSED_BLOCK_SIZE: u32 = 0x912E;
pub const GL_PACK_COMPRESSED_BLOCK_WIDTH: u32 = 0x912B;
pub const GL_PACK_IMAGE_HEIGHT: u32 = 0x806C;
pub const GL_PACK_LSB_FIRST: u32 = 0x0D01;
pub const GL_PACK_ROW_LENGTH: u32 = 0x0D02;
pub const GL_PACK_SKIP_IMAGES: u32 = 0x806B;
pub const GL_PACK_SKIP_PIXELS: u32 = 0x0D04;
pub const GL_PACK_SKIP_ROWS: u32 = 0x0D03;
pub const GL_PACK_SWAP_BYTES: u32 = 0x0D00;
pub const GL_PARAMETER_BUFFER: u32 = 0x80EE;
pub const GL_PARAMETER_BUFFER_BINDING: u32 = 0x80EF;
pub const GL_PATCHES: u32 = 0x000E;
pub const GL_PATCH_DEFAULT_INNER_LEVEL: u32 = 0x8E73;
pub const GL_PATCH_DEFAULT_OUTER_LEVEL: u32 = 0x8E74;
pub const GL_PATCH_VERTICES: u32 = 0x8E72;
pub const GL_PIXEL_BUFFER_BARRIER_BIT: u32 = 0x00000080;
pub const GL_PIXEL_PACK_BUFFER: u32 = 0x88EB;
pub const GL_PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
pub const GL_PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
pub const GL_PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
pub const GL_POINT: u32 = 0x1B00;
pub const GL_POINTS: u32 = 0x0000;
pub const GL_POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
pub const GL_POINT_SIZE: u32 = 0x0B11;
pub const GL_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
pub const GL_POINT_SIZE_RANGE: u32 = 0x0B12;
pub const GL_POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
pub const GL_POLYGON_MODE: u32 = 0x0B40;
pub const GL_POLYGON_OFFSET_CLAMP: u32 = 0x8E1B;
pub const GL_POLYGON_OFFSET_FACTOR: u32 = 0x8038;
pub const GL_POLYGON_OFFSET_FILL: u32 = 0x8037;
pub const GL_POLYGON_OFFSET_LINE: u32 = 0x2A02;
pub const GL_POLYGON_OFFSET_POINT: u32 = 0x2A01;
pub const GL_POLYGON_OFFSET_UNITS: u32 = 0x2A00;
pub const GL_POLYGON_SMOOTH: u32 = 0x0B41;
pub const GL_POLYGON_SMOOTH_HINT: u32 = 0x0C53;
pub const GL_PRIMITIVES_GENERATED: u32 = 0x8C87;
pub const GL_PRIMITIVES_SUBMITTED: u32 = 0x82EF;
pub const GL_PRIMITIVE_RESTART: u32 = 0x8F9D;
pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
pub const GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: u32 = 0x8221;
pub const GL_PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
pub const GL_PROGRAM: u32 = 0x82E2;
pub const GL_PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
pub const GL_PROGRAM_BINARY_LENGTH: u32 = 0x8741;
pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
pub const GL_PROGRAM_INPUT: u32 = 0x92E3;
pub const GL_PROGRAM_KHR: u32 = 0x82E2;
pub const GL_PROGRAM_OUTPUT: u32 = 0x92E4;
pub const GL_PROGRAM_PIPELINE: u32 = 0x82E4;
pub const GL_PROGRAM_PIPELINE_BINDING: u32 = 0x825A;
pub const GL_PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
pub const GL_PROGRAM_POINT_SIZE: u32 = 0x8642;
pub const GL_PROGRAM_SEPARABLE: u32 = 0x8258;
pub const GL_PROVOKING_VERTEX: u32 = 0x8E4F;
pub const GL_PROXY_TEXTURE_1D: u32 = 0x8063;
pub const GL_PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
pub const GL_PROXY_TEXTURE_2D: u32 = 0x8064;
pub const GL_PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
pub const GL_PROXY_TEXTURE_3D: u32 = 0x8070;
pub const GL_PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
pub const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: u32 = 0x900B;
pub const GL_PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
pub const GL_QUADS: u32 = 0x0007;
pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
pub const GL_QUERY: u32 = 0x82E3;
pub const GL_QUERY_BUFFER: u32 = 0x9192;
pub const GL_QUERY_BUFFER_BARRIER_BIT: u32 = 0x00008000;
pub const GL_QUERY_BUFFER_BINDING: u32 = 0x9193;
pub const GL_QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
pub const GL_QUERY_BY_REGION_NO_WAIT_INVERTED: u32 = 0x8E1A;
pub const GL_QUERY_BY_REGION_WAIT: u32 = 0x8E15;
pub const GL_QUERY_BY_REGION_WAIT_INVERTED: u32 = 0x8E19;
pub const GL_QUERY_COUNTER_BITS: u32 = 0x8864;
pub const GL_QUERY_KHR: u32 = 0x82E3;
pub const GL_QUERY_NO_WAIT: u32 = 0x8E14;
pub const GL_QUERY_NO_WAIT_INVERTED: u32 = 0x8E18;
pub const GL_QUERY_RESULT: u32 = 0x8866;
pub const GL_QUERY_RESULT_AVAILABLE: u32 = 0x8867;
pub const GL_QUERY_RESULT_NO_WAIT: u32 = 0x9194;
pub const GL_QUERY_TARGET: u32 = 0x82EA;
pub const GL_QUERY_WAIT: u32 = 0x8E13;
pub const GL_QUERY_WAIT_INVERTED: u32 = 0x8E17;
pub const GL_R11F_G11F_B10F: u32 = 0x8C3A;
pub const GL_R16: u32 = 0x822A;
pub const GL_R16F: u32 = 0x822D;
pub const GL_R16I: u32 = 0x8233;
pub const GL_R16UI: u32 = 0x8234;
pub const GL_R16_SNORM: u32 = 0x8F98;
pub const GL_R32F: u32 = 0x822E;
pub const GL_R32I: u32 = 0x8235;
pub const GL_R32UI: u32 = 0x8236;
pub const GL_R3_G3_B2: u32 = 0x2A10;
pub const GL_R8: u32 = 0x8229;
pub const GL_R8I: u32 = 0x8231;
pub const GL_R8UI: u32 = 0x8232;
pub const GL_R8_SNORM: u32 = 0x8F94;
pub const GL_RASTERIZER_DISCARD: u32 = 0x8C89;
pub const GL_READ_BUFFER: u32 = 0x0C02;
pub const GL_READ_FRAMEBUFFER: u32 = 0x8CA8;
pub const GL_READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
pub const GL_READ_ONLY: u32 = 0x88B8;
pub const GL_READ_PIXELS: u32 = 0x828C;
pub const GL_READ_PIXELS_FORMAT: u32 = 0x828D;
pub const GL_READ_PIXELS_TYPE: u32 = 0x828E;
pub const GL_READ_WRITE: u32 = 0x88BA;
pub const GL_RED: u32 = 0x1903;
pub const GL_RED_INTEGER: u32 = 0x8D94;
pub const GL_REFERENCED_BY_COMPUTE_SHADER: u32 = 0x930B;
pub const GL_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x930A;
pub const GL_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x9309;
pub const GL_REFERENCED_BY_TESS_CONTROL_SHADER: u32 = 0x9307;
pub const GL_REFERENCED_BY_TESS_EVALUATION_SHADER: u32 = 0x9308;
pub const GL_REFERENCED_BY_VERTEX_SHADER: u32 = 0x9306;
pub const GL_RENDERBUFFER: u32 = 0x8D41;
pub const GL_RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
pub const GL_RENDERBUFFER_BINDING: u32 = 0x8CA7;
pub const GL_RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
pub const GL_RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
pub const GL_RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
pub const GL_RENDERBUFFER_HEIGHT: u32 = 0x8D43;
pub const GL_RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
pub const GL_RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
pub const GL_RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
pub const GL_RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
pub const GL_RENDERBUFFER_WIDTH: u32 = 0x8D42;
pub const GL_RENDERER: u32 = 0x1F01;
pub const GL_REPEAT: u32 = 0x2901;
pub const GL_REPLACE: u32 = 0x1E01;
pub const GL_RESET_NOTIFICATION_STRATEGY: u32 = 0x8256;
pub const GL_RG: u32 = 0x8227;
pub const GL_RG16: u32 = 0x822C;
pub const GL_RG16F: u32 = 0x822F;
pub const GL_RG16I: u32 = 0x8239;
pub const GL_RG16UI: u32 = 0x823A;
pub const GL_RG16_SNORM: u32 = 0x8F99;
pub const GL_RG32F: u32 = 0x8230;
pub const GL_RG32I: u32 = 0x823B;
pub const GL_RG32UI: u32 = 0x823C;
pub const GL_RG8: u32 = 0x822B;
pub const GL_RG8I: u32 = 0x8237;
pub const GL_RG8UI: u32 = 0x8238;
pub const GL_RG8_SNORM: u32 = 0x8F95;
pub const GL_RGB: u32 = 0x1907;
pub const GL_RGB10: u32 = 0x8052;
pub const GL_RGB10_A2: u32 = 0x8059;
pub const GL_RGB10_A2UI: u32 = 0x906F;
pub const GL_RGB12: u32 = 0x8053;
pub const GL_RGB16: u32 = 0x8054;
pub const GL_RGB16F: u32 = 0x881B;
pub const GL_RGB16I: u32 = 0x8D89;
pub const GL_RGB16UI: u32 = 0x8D77;
pub const GL_RGB16_SNORM: u32 = 0x8F9A;
pub const GL_RGB32F: u32 = 0x8815;
pub const GL_RGB32I: u32 = 0x8D83;
pub const GL_RGB32UI: u32 = 0x8D71;
pub const GL_RGB4: u32 = 0x804F;
pub const GL_RGB5: u32 = 0x8050;
pub const GL_RGB565: u32 = 0x8D62;
pub const GL_RGB5_A1: u32 = 0x8057;
pub const GL_RGB8: u32 = 0x8051;
pub const GL_RGB8I: u32 = 0x8D8F;
pub const GL_RGB8UI: u32 = 0x8D7D;
pub const GL_RGB8_SNORM: u32 = 0x8F96;
pub const GL_RGB9_E5: u32 = 0x8C3D;
pub const GL_RGBA: u32 = 0x1908;
pub const GL_RGBA12: u32 = 0x805A;
pub const GL_RGBA16: u32 = 0x805B;
pub const GL_RGBA16F: u32 = 0x881A;
pub const GL_RGBA16I: u32 = 0x8D88;
pub const GL_RGBA16UI: u32 = 0x8D76;
pub const GL_RGBA16_SNORM: u32 = 0x8F9B;
pub const GL_RGBA2: u32 = 0x8055;
pub const GL_RGBA32F: u32 = 0x8814;
pub const GL_RGBA32I: u32 = 0x8D82;
pub const GL_RGBA32UI: u32 = 0x8D70;
pub const GL_RGBA4: u32 = 0x8056;
pub const GL_RGBA8: u32 = 0x8058;
pub const GL_RGBA8I: u32 = 0x8D8E;
pub const GL_RGBA8UI: u32 = 0x8D7C;
pub const GL_RGBA8_SNORM: u32 = 0x8F97;
pub const GL_RGBA_INTEGER: u32 = 0x8D99;
pub const GL_RGB_INTEGER: u32 = 0x8D98;
pub const GL_RG_INTEGER: u32 = 0x8228;
pub const GL_RIGHT: u32 = 0x0407;
pub const GL_SAMPLER: u32 = 0x82E6;
pub const GL_SAMPLER_1D: u32 = 0x8B5D;
pub const GL_SAMPLER_1D_ARRAY: u32 = 0x8DC0;
pub const GL_SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
pub const GL_SAMPLER_1D_SHADOW: u32 = 0x8B61;
pub const GL_SAMPLER_2D: u32 = 0x8B5E;
pub const GL_SAMPLER_2D_ARRAY: u32 = 0x8DC1;
pub const GL_SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
pub const GL_SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
pub const GL_SAMPLER_2D_RECT: u32 = 0x8B63;
pub const GL_SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
pub const GL_SAMPLER_2D_SHADOW: u32 = 0x8B62;
pub const GL_SAMPLER_3D: u32 = 0x8B5F;
pub const GL_SAMPLER_BINDING: u32 = 0x8919;
pub const GL_SAMPLER_BUFFER: u32 = 0x8DC2;
pub const GL_SAMPLER_CUBE: u32 = 0x8B60;
pub const GL_SAMPLER_CUBE_MAP_ARRAY: u32 = 0x900C;
pub const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: u32 = 0x900D;
pub const GL_SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
pub const GL_SAMPLER_KHR: u32 = 0x82E6;
pub const GL_SAMPLES: u32 = 0x80A9;
pub const GL_SAMPLES_PASSED: u32 = 0x8914;
pub const GL_SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
pub const GL_SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
pub const GL_SAMPLE_BUFFERS: u32 = 0x80A8;
pub const GL_SAMPLE_COVERAGE: u32 = 0x80A0;
pub const GL_SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
pub const GL_SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
pub const GL_SAMPLE_MASK: u32 = 0x8E51;
pub const GL_SAMPLE_MASK_VALUE: u32 = 0x8E52;
pub const GL_SAMPLE_POSITION: u32 = 0x8E50;
pub const GL_SAMPLE_SHADING: u32 = 0x8C36;
pub const GL_SCISSOR_BOX: u32 = 0x0C10;
pub const GL_SCISSOR_TEST: u32 = 0x0C11;
pub const GL_SEPARATE_ATTRIBS: u32 = 0x8C8D;
pub const GL_SET: u32 = 0x150F;
pub const GL_SHADER: u32 = 0x82E1;
pub const GL_SHADER_BINARY_FORMATS: u32 = 0x8DF8;
pub const GL_SHADER_BINARY_FORMAT_SPIR_V: u32 = 0x9551;
pub const GL_SHADER_COMPILER: u32 = 0x8DFA;
pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: u32 = 0x00000020;
pub const GL_SHADER_IMAGE_ATOMIC: u32 = 0x82A6;
pub const GL_SHADER_IMAGE_LOAD: u32 = 0x82A4;
pub const GL_SHADER_IMAGE_STORE: u32 = 0x82A5;
pub const GL_SHADER_KHR: u32 = 0x82E1;
pub const GL_SHADER_SOURCE_LENGTH: u32 = 0x8B88;
pub const GL_SHADER_STORAGE_BARRIER_BIT: u32 = 0x00002000;
pub const GL_SHADER_STORAGE_BLOCK: u32 = 0x92E6;
pub const GL_SHADER_STORAGE_BUFFER: u32 = 0x90D2;
pub const GL_SHADER_STORAGE_BUFFER_BINDING: u32 = 0x90D3;
pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: u32 = 0x90DF;
pub const GL_SHADER_STORAGE_BUFFER_SIZE: u32 = 0x90D5;
pub const GL_SHADER_STORAGE_BUFFER_START: u32 = 0x90D4;
pub const GL_SHADER_TYPE: u32 = 0x8B4F;
pub const GL_SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
pub const GL_SHORT: u32 = 0x1402;
pub const GL_SIGNALED: u32 = 0x9119;
pub const GL_SIGNED_NORMALIZED: u32 = 0x8F9C;
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: u32 = 0x82AC;
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: u32 = 0x82AE;
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: u32 = 0x82AD;
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: u32 = 0x82AF;
pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
pub const GL_SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
pub const GL_SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
pub const GL_SPIR_V_BINARY: u32 = 0x9552;
pub const GL_SPIR_V_EXTENSIONS: u32 = 0x9553;
pub const GL_SRC1_ALPHA: u32 = 0x8589;
pub const GL_SRC1_COLOR: u32 = 0x88F9;
pub const GL_SRC_ALPHA: u32 = 0x0302;
pub const GL_SRC_ALPHA_SATURATE: u32 = 0x0308;
pub const GL_SRC_COLOR: u32 = 0x0300;
pub const GL_SRGB: u32 = 0x8C40;
pub const GL_SRGB8: u32 = 0x8C41;
pub const GL_SRGB8_ALPHA8: u32 = 0x8C43;
pub const GL_SRGB_ALPHA: u32 = 0x8C42;
pub const GL_SRGB_READ: u32 = 0x8297;
pub const GL_SRGB_WRITE: u32 = 0x8298;
pub const GL_STACK_OVERFLOW: u32 = 0x0503;
pub const GL_STACK_OVERFLOW_KHR: u32 = 0x0503;
pub const GL_STACK_UNDERFLOW: u32 = 0x0504;
pub const GL_STACK_UNDERFLOW_KHR: u32 = 0x0504;
pub const GL_STATIC_COPY: u32 = 0x88E6;
pub const GL_STATIC_DRAW: u32 = 0x88E4;
pub const GL_STATIC_READ: u32 = 0x88E5;
pub const GL_STENCIL: u32 = 0x1802;
pub const GL_STENCIL_ATTACHMENT: u32 = 0x8D20;
pub const GL_STENCIL_BACK_FAIL: u32 = 0x8801;
pub const GL_STENCIL_BACK_FUNC: u32 = 0x8800;
pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
pub const GL_STENCIL_BACK_REF: u32 = 0x8CA3;
pub const GL_STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
pub const GL_STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
pub const GL_STENCIL_BUFFER_BIT: u32 = 0x00000400;
pub const GL_STENCIL_CLEAR_VALUE: u32 = 0x0B91;
pub const GL_STENCIL_COMPONENTS: u32 = 0x8285;
pub const GL_STENCIL_FAIL: u32 = 0x0B94;
pub const GL_STENCIL_FUNC: u32 = 0x0B92;
pub const GL_STENCIL_INDEX: u32 = 0x1901;
pub const GL_STENCIL_INDEX1: u32 = 0x8D46;
pub const GL_STENCIL_INDEX16: u32 = 0x8D49;
pub const GL_STENCIL_INDEX4: u32 = 0x8D47;
pub const GL_STENCIL_INDEX8: u32 = 0x8D48;
pub const GL_STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
pub const GL_STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
pub const GL_STENCIL_REF: u32 = 0x0B97;
pub const GL_STENCIL_RENDERABLE: u32 = 0x8288;
pub const GL_STENCIL_TEST: u32 = 0x0B90;
pub const GL_STENCIL_VALUE_MASK: u32 = 0x0B93;
pub const GL_STENCIL_WRITEMASK: u32 = 0x0B98;
pub const GL_STEREO: u32 = 0x0C33;
pub const GL_STREAM_COPY: u32 = 0x88E2;
pub const GL_STREAM_DRAW: u32 = 0x88E0;
pub const GL_STREAM_READ: u32 = 0x88E1;
pub const GL_SUBPIXEL_BITS: u32 = 0x0D50;
pub const GL_SYNC_CONDITION: u32 = 0x9113;
pub const GL_SYNC_FENCE: u32 = 0x9116;
pub const GL_SYNC_FLAGS: u32 = 0x9115;
pub const GL_SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
pub const GL_SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
pub const GL_SYNC_STATUS: u32 = 0x9114;
pub const GL_TESS_CONTROL_OUTPUT_VERTICES: u32 = 0x8E75;
pub const GL_TESS_CONTROL_SHADER: u32 = 0x8E88;
pub const GL_TESS_CONTROL_SHADER_BIT: u32 = 0x00000008;
pub const GL_TESS_CONTROL_SHADER_PATCHES: u32 = 0x82F1;
pub const GL_TESS_CONTROL_SUBROUTINE: u32 = 0x92E9;
pub const GL_TESS_CONTROL_SUBROUTINE_UNIFORM: u32 = 0x92EF;
pub const GL_TESS_CONTROL_TEXTURE: u32 = 0x829C;
pub const GL_TESS_EVALUATION_SHADER: u32 = 0x8E87;
pub const GL_TESS_EVALUATION_SHADER_BIT: u32 = 0x00000010;
pub const GL_TESS_EVALUATION_SHADER_INVOCATIONS: u32 = 0x82F2;
pub const GL_TESS_EVALUATION_SUBROUTINE: u32 = 0x92EA;
pub const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: u32 = 0x92F0;
pub const GL_TESS_EVALUATION_TEXTURE: u32 = 0x829D;
pub const GL_TESS_GEN_MODE: u32 = 0x8E76;
pub const GL_TESS_GEN_POINT_MODE: u32 = 0x8E79;
pub const GL_TESS_GEN_SPACING: u32 = 0x8E77;
pub const GL_TESS_GEN_VERTEX_ORDER: u32 = 0x8E78;
pub const GL_TEXTURE: u32 = 0x1702;
pub const GL_TEXTURE0: u32 = 0x84C0;
pub const GL_TEXTURE1: u32 = 0x84C1;
pub const GL_TEXTURE10: u32 = 0x84CA;
pub const GL_TEXTURE11: u32 = 0x84CB;
pub const GL_TEXTURE12: u32 = 0x84CC;
pub const GL_TEXTURE13: u32 = 0x84CD;
pub const GL_TEXTURE14: u32 = 0x84CE;
pub const GL_TEXTURE15: u32 = 0x84CF;
pub const GL_TEXTURE16: u32 = 0x84D0;
pub const GL_TEXTURE17: u32 = 0x84D1;
pub const GL_TEXTURE18: u32 = 0x84D2;
pub const GL_TEXTURE19: u32 = 0x84D3;
pub const GL_TEXTURE2: u32 = 0x84C2;
pub const GL_TEXTURE20: u32 = 0x84D4;
pub const GL_TEXTURE21: u32 = 0x84D5;
pub const GL_TEXTURE22: u32 = 0x84D6;
pub const GL_TEXTURE23: u32 = 0x84D7;
pub const GL_TEXTURE24: u32 = 0x84D8;
pub const GL_TEXTURE25: u32 = 0x84D9;
pub const GL_TEXTURE26: u32 = 0x84DA;
pub const GL_TEXTURE27: u32 = 0x84DB;
pub const GL_TEXTURE28: u32 = 0x84DC;
pub const GL_TEXTURE29: u32 = 0x84DD;
pub const GL_TEXTURE3: u32 = 0x84C3;
pub const GL_TEXTURE30: u32 = 0x84DE;
pub const GL_TEXTURE31: u32 = 0x84DF;
pub const GL_TEXTURE4: u32 = 0x84C4;
pub const GL_TEXTURE5: u32 = 0x84C5;
pub const GL_TEXTURE6: u32 = 0x84C6;
pub const GL_TEXTURE7: u32 = 0x84C7;
pub const GL_TEXTURE8: u32 = 0x84C8;
pub const GL_TEXTURE9: u32 = 0x84C9;
pub const GL_TEXTURE_1D: u32 = 0x0DE0;
pub const GL_TEXTURE_1D_ARRAY: u32 = 0x8C18;
pub const GL_TEXTURE_2D: u32 = 0x0DE1;
pub const GL_TEXTURE_2D_ARRAY: u32 = 0x8C1A;
pub const GL_TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
pub const GL_TEXTURE_3D: u32 = 0x806F;
pub const GL_TEXTURE_ALPHA_SIZE: u32 = 0x805F;
pub const GL_TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
pub const GL_TEXTURE_BASE_LEVEL: u32 = 0x813C;
pub const GL_TEXTURE_BINDING_1D: u32 = 0x8068;
pub const GL_TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
pub const GL_TEXTURE_BINDING_2D: u32 = 0x8069;
pub const GL_TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
pub const GL_TEXTURE_BINDING_3D: u32 = 0x806A;
pub const GL_TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
pub const GL_TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
pub const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: u32 = 0x900A;
pub const GL_TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
pub const GL_TEXTURE_BLUE_SIZE: u32 = 0x805E;
pub const GL_TEXTURE_BLUE_TYPE: u32 = 0x8C12;
pub const GL_TEXTURE_BORDER_COLOR: u32 = 0x1004;
pub const GL_TEXTURE_BUFFER: u32 = 0x8C2A;
pub const GL_TEXTURE_BUFFER_BINDING: u32 = 0x8C2A;
pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
pub const GL_TEXTURE_BUFFER_OFFSET: u32 = 0x919D;
pub const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: u32 = 0x919F;
pub const GL_TEXTURE_BUFFER_SIZE: u32 = 0x919E;
pub const GL_TEXTURE_COMPARE_FUNC: u32 = 0x884D;
pub const GL_TEXTURE_COMPARE_MODE: u32 = 0x884C;
pub const GL_TEXTURE_COMPRESSED: u32 = 0x86A1;
pub const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: u32 = 0x82B2;
pub const GL_TEXTURE_COMPRESSED_BLOCK_SIZE: u32 = 0x82B3;
pub const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: u32 = 0x82B1;
pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
pub const GL_TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
pub const GL_TEXTURE_CUBE_MAP: u32 = 0x8513;
pub const GL_TEXTURE_CUBE_MAP_ARRAY: u32 = 0x9009;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
pub const GL_TEXTURE_DEPTH: u32 = 0x8071;
pub const GL_TEXTURE_DEPTH_SIZE: u32 = 0x884A;
pub const GL_TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
pub const GL_TEXTURE_FETCH_BARRIER_BIT: u32 = 0x00000008;
pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
pub const GL_TEXTURE_GATHER: u32 = 0x82A2;
pub const GL_TEXTURE_GATHER_SHADOW: u32 = 0x82A3;
pub const GL_TEXTURE_GREEN_SIZE: u32 = 0x805D;
pub const GL_TEXTURE_GREEN_TYPE: u32 = 0x8C11;
pub const GL_TEXTURE_HEIGHT: u32 = 0x1001;
pub const GL_TEXTURE_IMAGE_FORMAT: u32 = 0x828F;
pub const GL_TEXTURE_IMAGE_TYPE: u32 = 0x8290;
pub const GL_TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
pub const GL_TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
pub const GL_TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
pub const GL_TEXTURE_LOD_BIAS: u32 = 0x8501;
pub const GL_TEXTURE_MAG_FILTER: u32 = 0x2800;
pub const GL_TEXTURE_MAX_ANISOTROPY: u32 = 0x84FE;
pub const GL_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
pub const GL_TEXTURE_MAX_LEVEL: u32 = 0x813D;
pub const GL_TEXTURE_MAX_LOD: u32 = 0x813B;
pub const GL_TEXTURE_MIN_FILTER: u32 = 0x2801;
pub const GL_TEXTURE_MIN_LOD: u32 = 0x813A;
pub const GL_TEXTURE_RECTANGLE: u32 = 0x84F5;
pub const GL_TEXTURE_RED_SIZE: u32 = 0x805C;
pub const GL_TEXTURE_RED_TYPE: u32 = 0x8C10;
pub const GL_TEXTURE_SAMPLES: u32 = 0x9106;
pub const GL_TEXTURE_SHADOW: u32 = 0x82A1;
pub const GL_TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
pub const GL_TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
pub const GL_TEXTURE_SWIZZLE_A: u32 = 0x8E45;
pub const GL_TEXTURE_SWIZZLE_B: u32 = 0x8E44;
pub const GL_TEXTURE_SWIZZLE_G: u32 = 0x8E43;
pub const GL_TEXTURE_SWIZZLE_R: u32 = 0x8E42;
pub const GL_TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
pub const GL_TEXTURE_TARGET: u32 = 0x1006;
pub const GL_TEXTURE_UPDATE_BARRIER_BIT: u32 = 0x00000100;
pub const GL_TEXTURE_VIEW: u32 = 0x82B5;
pub const GL_TEXTURE_VIEW_MIN_LAYER: u32 = 0x82DD;
pub const GL_TEXTURE_VIEW_MIN_LEVEL: u32 = 0x82DB;
pub const GL_TEXTURE_VIEW_NUM_LAYERS: u32 = 0x82DE;
pub const GL_TEXTURE_VIEW_NUM_LEVELS: u32 = 0x82DC;
pub const GL_TEXTURE_WIDTH: u32 = 0x1000;
pub const GL_TEXTURE_WRAP_R: u32 = 0x8072;
pub const GL_TEXTURE_WRAP_S: u32 = 0x2802;
pub const GL_TEXTURE_WRAP_T: u32 = 0x2803;
pub const GL_TIMEOUT_EXPIRED: u32 = 0x911B;
pub const GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
pub const GL_TIMESTAMP: u32 = 0x8E28;
pub const GL_TIME_ELAPSED: u32 = 0x88BF;
pub const GL_TOP_LEVEL_ARRAY_SIZE: u32 = 0x930C;
pub const GL_TOP_LEVEL_ARRAY_STRIDE: u32 = 0x930D;
pub const GL_TRANSFORM_FEEDBACK: u32 = 0x8E22;
pub const GL_TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: u32 = 0x00000800;
pub const GL_TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
pub const GL_TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: u32 = 0x8E24;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: u32 = 0x934B;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: u32 = 0x8E23;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: u32 = 0x934C;
pub const GL_TRANSFORM_FEEDBACK_OVERFLOW: u32 = 0x82EC;
pub const GL_TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
pub const GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: u32 = 0x82ED;
pub const GL_TRANSFORM_FEEDBACK_VARYING: u32 = 0x92F4;
pub const GL_TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
pub const GL_TRIANGLES: u32 = 0x0004;
pub const GL_TRIANGLES_ADJACENCY: u32 = 0x000C;
pub const GL_TRIANGLE_FAN: u32 = 0x0006;
pub const GL_TRIANGLE_STRIP: u32 = 0x0005;
pub const GL_TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
pub const GL_TRUE: u32 = 1;
pub const GL_TYPE: u32 = 0x92FA;
pub const GL_UNDEFINED_VERTEX: u32 = 0x8260;
pub const GL_UNIFORM: u32 = 0x92E1;
pub const GL_UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
pub const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: u32 = 0x92DA;
pub const GL_UNIFORM_BARRIER_BIT: u32 = 0x00000004;
pub const GL_UNIFORM_BLOCK: u32 = 0x92E2;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
pub const GL_UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
pub const GL_UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
pub const GL_UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
pub const GL_UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: u32 = 0x90EC;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: u32 = 0x84F0;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: u32 = 0x84F1;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
pub const GL_UNIFORM_BUFFER: u32 = 0x8A11;
pub const GL_UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
pub const GL_UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
pub const GL_UNIFORM_BUFFER_START: u32 = 0x8A29;
pub const GL_UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
pub const GL_UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
pub const GL_UNIFORM_NAME_LENGTH: u32 = 0x8A39;
pub const GL_UNIFORM_OFFSET: u32 = 0x8A3B;
pub const GL_UNIFORM_SIZE: u32 = 0x8A38;
pub const GL_UNIFORM_TYPE: u32 = 0x8A37;
pub const GL_UNKNOWN_CONTEXT_RESET: u32 = 0x8255;
pub const GL_UNPACK_ALIGNMENT: u32 = 0x0CF5;
pub const GL_UNPACK_COMPRESSED_BLOCK_DEPTH: u32 = 0x9129;
pub const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: u32 = 0x9128;
pub const GL_UNPACK_COMPRESSED_BLOCK_SIZE: u32 = 0x912A;
pub const GL_UNPACK_COMPRESSED_BLOCK_WIDTH: u32 = 0x9127;
pub const GL_UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
pub const GL_UNPACK_LSB_FIRST: u32 = 0x0CF1;
pub const GL_UNPACK_ROW_LENGTH: u32 = 0x0CF2;
pub const GL_UNPACK_SKIP_IMAGES: u32 = 0x806D;
pub const GL_UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
pub const GL_UNPACK_SKIP_ROWS: u32 = 0x0CF3;
pub const GL_UNPACK_SWAP_BYTES: u32 = 0x0CF0;
pub const GL_UNSIGNALED: u32 = 0x9118;
pub const GL_UNSIGNED_BYTE: u32 = 0x1401;
pub const GL_UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
pub const GL_UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
pub const GL_UNSIGNED_INT: u32 = 0x1405;
pub const GL_UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
pub const GL_UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
pub const GL_UNSIGNED_INT_24_8: u32 = 0x84FA;
pub const GL_UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
pub const GL_UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
pub const GL_UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
pub const GL_UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: u32 = 0x92DB;
pub const GL_UNSIGNED_INT_IMAGE_1D: u32 = 0x9062;
pub const GL_UNSIGNED_INT_IMAGE_1D_ARRAY: u32 = 0x9068;
pub const GL_UNSIGNED_INT_IMAGE_2D: u32 = 0x9063;
pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: u32 = 0x9069;
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: u32 = 0x906B;
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: u32 = 0x906C;
pub const GL_UNSIGNED_INT_IMAGE_2D_RECT: u32 = 0x9065;
pub const GL_UNSIGNED_INT_IMAGE_3D: u32 = 0x9064;
pub const GL_UNSIGNED_INT_IMAGE_BUFFER: u32 = 0x9067;
pub const GL_UNSIGNED_INT_IMAGE_CUBE: u32 = 0x9066;
pub const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: u32 = 0x906A;
pub const GL_UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
pub const GL_UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
pub const GL_UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
pub const GL_UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
pub const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: u32 = 0x900F;
pub const GL_UNSIGNED_INT_VEC2: u32 = 0x8DC6;
pub const GL_UNSIGNED_INT_VEC3: u32 = 0x8DC7;
pub const GL_UNSIGNED_INT_VEC4: u32 = 0x8DC8;
pub const GL_UNSIGNED_NORMALIZED: u32 = 0x8C17;
pub const GL_UNSIGNED_SHORT: u32 = 0x1403;
pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
pub const GL_UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
pub const GL_UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
pub const GL_UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
pub const GL_UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
pub const GL_UPPER_LEFT: u32 = 0x8CA2;
pub const GL_VALIDATE_STATUS: u32 = 0x8B83;
pub const GL_VENDOR: u32 = 0x1F00;
pub const GL_VERSION: u32 = 0x1F02;
pub const GL_VERTEX_ARRAY: u32 = 0x8074;
pub const GL_VERTEX_ARRAY_BINDING: u32 = 0x85B5;
pub const GL_VERTEX_ARRAY_KHR: u32 = 0x8074;
pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: u32 = 0x00000001;
pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB: u32 = 0x88FE;
pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
pub const GL_VERTEX_ATTRIB_ARRAY_LONG: u32 = 0x874E;
pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
pub const GL_VERTEX_ATTRIB_BINDING: u32 = 0x82D4;
pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: u32 = 0x82D5;
pub const GL_VERTEX_BINDING_BUFFER: u32 = 0x8F4F;
pub const GL_VERTEX_BINDING_DIVISOR: u32 = 0x82D6;
pub const GL_VERTEX_BINDING_OFFSET: u32 = 0x82D7;
pub const GL_VERTEX_BINDING_STRIDE: u32 = 0x82D8;
pub const GL_VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
pub const GL_VERTEX_SHADER: u32 = 0x8B31;
pub const GL_VERTEX_SHADER_BIT: u32 = 0x00000001;
pub const GL_VERTEX_SHADER_INVOCATIONS: u32 = 0x82F0;
pub const GL_VERTEX_SUBROUTINE: u32 = 0x92E8;
pub const GL_VERTEX_SUBROUTINE_UNIFORM: u32 = 0x92EE;
pub const GL_VERTEX_TEXTURE: u32 = 0x829B;
pub const GL_VERTICES_SUBMITTED: u32 = 0x82EE;
pub const GL_VIEWPORT: u32 = 0x0BA2;
pub const GL_VIEWPORT_BOUNDS_RANGE: u32 = 0x825D;
pub const GL_VIEWPORT_INDEX_PROVOKING_VERTEX: u32 = 0x825F;
pub const GL_VIEWPORT_SUBPIXEL_BITS: u32 = 0x825C;
pub const GL_VIEW_CLASS_128_BITS: u32 = 0x82C4;
pub const GL_VIEW_CLASS_16_BITS: u32 = 0x82CA;
pub const GL_VIEW_CLASS_24_BITS: u32 = 0x82C9;
pub const GL_VIEW_CLASS_32_BITS: u32 = 0x82C8;
pub const GL_VIEW_CLASS_48_BITS: u32 = 0x82C7;
pub const GL_VIEW_CLASS_64_BITS: u32 = 0x82C6;
pub const GL_VIEW_CLASS_8_BITS: u32 = 0x82CB;
pub const GL_VIEW_CLASS_96_BITS: u32 = 0x82C5;
pub const GL_VIEW_CLASS_BPTC_FLOAT: u32 = 0x82D3;
pub const GL_VIEW_CLASS_BPTC_UNORM: u32 = 0x82D2;
pub const GL_VIEW_CLASS_RGTC1_RED: u32 = 0x82D0;
pub const GL_VIEW_CLASS_RGTC2_RG: u32 = 0x82D1;
pub const GL_VIEW_CLASS_S3TC_DXT1_RGB: u32 = 0x82CC;
pub const GL_VIEW_CLASS_S3TC_DXT1_RGBA: u32 = 0x82CD;
pub const GL_VIEW_CLASS_S3TC_DXT3_RGBA: u32 = 0x82CE;
pub const GL_VIEW_CLASS_S3TC_DXT5_RGBA: u32 = 0x82CF;
pub const GL_VIEW_COMPATIBILITY_CLASS: u32 = 0x82B6;
pub const GL_WAIT_FAILED: u32 = 0x911D;
pub const GL_WRITE_ONLY: u32 = 0x88B9;
pub const GL_XOR: u32 = 0x1506;
pub const GL_ZERO: u32 = 0;
pub const GL_ZERO_TO_ONE: u32 = 0x935F;

      static glActiveShaderProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glActiveShaderProgram(pipeline: GLuint, program: GLuint, ) -> () {
        let u: usize = glActiveShaderProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, program, )
      }

      static glActiveTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glActiveTexture(texture: GLenum, ) -> () {
        let u: usize = glActiveTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, )
      }

      static glAttachShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glAttachShader(program: GLuint, shader: GLuint, ) -> () {
        let u: usize = glAttachShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shader, )
      }

      static glBeginConditionalRender_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBeginConditionalRender(id: GLuint, mode: GLenum, ) -> () {
        let u: usize = glBeginConditionalRender_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, mode, )
      }

      static glBeginQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBeginQuery(target: GLenum, id: GLuint, ) -> () {
        let u: usize = glBeginQuery_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, id, )
      }

      static glBeginQueryIndexed_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBeginQueryIndexed(target: GLenum, index: GLuint, id: GLuint, ) -> () {
        let u: usize = glBeginQueryIndexed_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, id, )
      }

      static glBeginTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBeginTransformFeedback(primitiveMode: GLenum, ) -> () {
        let u: usize = glBeginTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(primitiveMode, )
      }

      static glBindAttribLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindAttribLocation(program: GLuint, index: GLuint, name: *const GLchar, ) -> () {
        let u: usize = glBindAttribLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, index, name, )
      }

      static glBindBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindBuffer(target: GLenum, buffer: GLuint, ) -> () {
        let u: usize = glBindBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, buffer, )
      }

      static glBindBufferBase_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindBufferBase(target: GLenum, index: GLuint, buffer: GLuint, ) -> () {
        let u: usize = glBindBufferBase_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, buffer, )
      }

      static glBindBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindBufferRange(target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glBindBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, buffer, offset, size, )
      }

      static glBindBuffersBase_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindBuffersBase(target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, ) -> () {
        let u: usize = glBindBuffersBase_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, first, count, buffers, )
      }

      static glBindBuffersRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindBuffersRange(target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr, ) -> () {
        let u: usize = glBindBuffersRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLuint,*const GLintptr,*const GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, first, count, buffers, offsets, sizes, )
      }

      static glBindFragDataLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindFragDataLocation(program: GLuint, color: GLuint, name: *const GLchar, ) -> () {
        let u: usize = glBindFragDataLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, color, name, )
      }

      static glBindFragDataLocationIndexed_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindFragDataLocationIndexed(program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar, ) -> () {
        let u: usize = glBindFragDataLocationIndexed_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, colorNumber, index, name, )
      }

      static glBindFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindFramebuffer(target: GLenum, framebuffer: GLuint, ) -> () {
        let u: usize = glBindFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, framebuffer, )
      }

      static glBindImageTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindImageTexture(unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum, ) -> () {
        let u: usize = glBindImageTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLint,GLboolean,GLint,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(unit, texture, level, layered, layer, access, format, )
      }

      static glBindImageTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindImageTextures(first: GLuint, count: GLsizei, textures: *const GLuint, ) -> () {
        let u: usize = glBindImageTextures_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, textures, )
      }

      static glBindProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindProgramPipeline(pipeline: GLuint, ) -> () {
        let u: usize = glBindProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, )
      }

      static glBindRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindRenderbuffer(target: GLenum, renderbuffer: GLuint, ) -> () {
        let u: usize = glBindRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, renderbuffer, )
      }

      static glBindSampler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindSampler(unit: GLuint, sampler: GLuint, ) -> () {
        let u: usize = glBindSampler_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(unit, sampler, )
      }

      static glBindSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindSamplers(first: GLuint, count: GLsizei, samplers: *const GLuint, ) -> () {
        let u: usize = glBindSamplers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, samplers, )
      }

      static glBindTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindTexture(target: GLenum, texture: GLuint, ) -> () {
        let u: usize = glBindTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, texture, )
      }

      static glBindTextureUnit_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindTextureUnit(unit: GLuint, texture: GLuint, ) -> () {
        let u: usize = glBindTextureUnit_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(unit, texture, )
      }

      static glBindTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindTextures(first: GLuint, count: GLsizei, textures: *const GLuint, ) -> () {
        let u: usize = glBindTextures_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, textures, )
      }

      static glBindTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindTransformFeedback(target: GLenum, id: GLuint, ) -> () {
        let u: usize = glBindTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, id, )
      }

      static glBindVertexArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindVertexArray(array: GLuint, ) -> () {
        let u: usize = glBindVertexArray_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(array, )
      }

      static glBindVertexBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindVertexBuffer(bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei, ) -> () {
        let u: usize = glBindVertexBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLintptr,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(bindingindex, buffer, offset, stride, )
      }

      static glBindVertexBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBindVertexBuffers(first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei, ) -> () {
        let u: usize = glBindVertexBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLuint,*const GLintptr,*const GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, buffers, offsets, strides, )
      }

      static glBlendColor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat, ) -> () {
        let u: usize = glBlendColor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(red, green, blue, alpha, )
      }

      static glBlendEquation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendEquation(mode: GLenum, ) -> () {
        let u: usize = glBlendEquation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, )
      }

      static glBlendEquationSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum, ) -> () {
        let u: usize = glBlendEquationSeparate_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(modeRGB, modeAlpha, )
      }

      static glBlendEquationSeparatei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendEquationSeparatei(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum, ) -> () {
        let u: usize = glBlendEquationSeparatei_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buf, modeRGB, modeAlpha, )
      }

      static glBlendEquationi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendEquationi(buf: GLuint, mode: GLenum, ) -> () {
        let u: usize = glBlendEquationi_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buf, mode, )
      }

      static glBlendFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendFunc(sfactor: GLenum, dfactor: GLenum, ) -> () {
        let u: usize = glBlendFunc_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sfactor, dfactor, )
      }

      static glBlendFuncSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendFuncSeparate(sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum, ) -> () {
        let u: usize = glBlendFuncSeparate_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, )
      }

      static glBlendFuncSeparatei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendFuncSeparatei(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum, ) -> () {
        let u: usize = glBlendFuncSeparatei_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, )
      }

      static glBlendFunci_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlendFunci(buf: GLuint, src: GLenum, dst: GLenum, ) -> () {
        let u: usize = glBlendFunci_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buf, src, dst, )
      }

      static glBlitFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum, ) -> () {
        let u: usize = glBlitFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLbitfield,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, )
      }

      static glBlitNamedFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBlitNamedFramebuffer(readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum, ) -> () {
        let u: usize = glBlitNamedFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLbitfield,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, )
      }

      static glBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBufferData(target: GLenum, size: GLsizeiptr, data: *const void, usage: GLenum, ) -> () {
        let u: usize = glBufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizeiptr,*const void,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, size, data, usage, )
      }

      static glBufferStorage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBufferStorage(target: GLenum, size: GLsizeiptr, data: *const void, flags: GLbitfield, ) -> () {
        let u: usize = glBufferStorage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizeiptr,*const void,GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, size, data, flags, )
      }

      static glBufferStorageEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBufferStorageEXT(target: GLenum, size: GLsizeiptr, data: *const void, flags: GLbitfield, ) -> () {
        let u: usize = glBufferStorageEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizeiptr,*const void,GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, size, data, flags, )
      }

      static glBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glBufferSubData(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const void, ) -> () {
        let u: usize = glBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLintptr,GLsizeiptr,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, offset, size, data, )
      }

      static glCheckFramebufferStatus_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCheckFramebufferStatus(target: GLenum, ) -> GLenum {
        let u: usize = glCheckFramebufferStatus_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->GLenum = unsafe { core::mem::transmute(u) };
        _func_p(target, )
      }

      static glCheckNamedFramebufferStatus_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCheckNamedFramebufferStatus(framebuffer: GLuint, target: GLenum, ) -> GLenum {
        let u: usize = glCheckNamedFramebufferStatus_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->GLenum = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, target, )
      }

      static glClampColor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClampColor(target: GLenum, clamp: GLenum, ) -> () {
        let u: usize = glClampColor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, clamp, )
      }

      static glClear_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClear(mask: GLbitfield, ) -> () {
        let u: usize = glClear_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mask, )
      }

      static glClearBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferData(target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearBufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, format, type_, data, )
      }

      static glClearBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferSubData(target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLintptr,GLsizeiptr,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, offset, size, format, type_, data, )
      }

      static glClearBufferfi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint, ) -> () {
        let u: usize = glClearBufferfi_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLfloat,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, drawbuffer, depth, stencil, )
      }

      static glClearBufferfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferfv(buffer: GLenum, drawbuffer: GLint, value: *const GLfloat, ) -> () {
        let u: usize = glClearBufferfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, drawbuffer, value, )
      }

      static glClearBufferiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferiv(buffer: GLenum, drawbuffer: GLint, value: *const GLint, ) -> () {
        let u: usize = glClearBufferiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, drawbuffer, value, )
      }

      static glClearBufferuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearBufferuiv(buffer: GLenum, drawbuffer: GLint, value: *const GLuint, ) -> () {
        let u: usize = glClearBufferuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, drawbuffer, value, )
      }

      static glClearColor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat, ) -> () {
        let u: usize = glClearColor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(red, green, blue, alpha, )
      }

      static glClearDepth_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearDepth(depth: GLdouble, ) -> () {
        let u: usize = glClearDepth_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(depth, )
      }

      static glClearDepthf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearDepthf(d: GLfloat, ) -> () {
        let u: usize = glClearDepthf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(d, )
      }

      static glClearNamedBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedBufferData(buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearNamedBufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, internalformat, format, type_, data, )
      }

      static glClearNamedBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedBufferSubData(buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearNamedBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLintptr,GLsizeiptr,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, internalformat, offset, size, format, type_, data, )
      }

      static glClearNamedFramebufferfi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedFramebufferfi(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint, ) -> () {
        let u: usize = glClearNamedFramebufferfi_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,GLfloat,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, buffer, drawbuffer, depth, stencil, )
      }

      static glClearNamedFramebufferfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedFramebufferfv(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat, ) -> () {
        let u: usize = glClearNamedFramebufferfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, buffer, drawbuffer, value, )
      }

      static glClearNamedFramebufferiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedFramebufferiv(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint, ) -> () {
        let u: usize = glClearNamedFramebufferiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, buffer, drawbuffer, value, )
      }

      static glClearNamedFramebufferuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearNamedFramebufferuiv(framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint, ) -> () {
        let u: usize = glClearNamedFramebufferuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, buffer, drawbuffer, value, )
      }

      static glClearStencil_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearStencil(s: GLint, ) -> () {
        let u: usize = glClearStencil_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(s, )
      }

      static glClearTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearTexImage(texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, format, type_, data, )
      }

      static glClearTexSubImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClearTexSubImage(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const void, ) -> () {
        let u: usize = glClearTexSubImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data, )
      }

      static glClientWaitSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClientWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64, ) -> GLenum {
        let u: usize = glClientWaitSync_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsync,GLbitfield,GLuint64,)->GLenum = unsafe { core::mem::transmute(u) };
        _func_p(sync, flags, timeout, )
      }

      static glClipControl_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glClipControl(origin: GLenum, depth: GLenum, ) -> () {
        let u: usize = glClipControl_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(origin, depth, )
      }

      static glColorMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glColorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean, ) -> () {
        let u: usize = glColorMask_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLboolean,GLboolean,GLboolean,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(red, green, blue, alpha, )
      }

      static glColorMaskIndexedEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glColorMaskIndexedEXT(index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean, ) -> () {
        let u: usize = glColorMaskIndexedEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLboolean,GLboolean,GLboolean,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, r, g, b, a, )
      }

      static glColorMaski_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glColorMaski(index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean, ) -> () {
        let u: usize = glColorMaski_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLboolean,GLboolean,GLboolean,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, r, g, b, a, )
      }

      static glCompileShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompileShader(shader: GLuint, ) -> () {
        let u: usize = glCompileShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, )
      }

      static glCompressedTexImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexImage1D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, border, imageSize, data, )
      }

      static glCompressedTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, height, border, imageSize, data, )
      }

      static glCompressedTexImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, height, depth, border, imageSize, data, )
      }

      static glCompressedTexSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexSubImage1D(target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, width, format, imageSize, data, )
      }

      static glCompressedTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, width, height, format, imageSize, data, )
      }

      static glCompressedTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data, )
      }

      static glCompressedTextureSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTextureSubImage1D(texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTextureSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, width, format, imageSize, data, )
      }

      static glCompressedTextureSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTextureSubImage2D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTextureSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, width, height, format, imageSize, data, )
      }

      static glCompressedTextureSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCompressedTextureSubImage3D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const void, ) -> () {
        let u: usize = glCompressedTextureSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data, )
      }

      static glCopyBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glCopyBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLintptr,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(readTarget, writeTarget, readOffset, writeOffset, size, )
      }

      static glCopyBufferSubDataNV_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyBufferSubDataNV(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glCopyBufferSubDataNV_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLintptr,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(readTarget, writeTarget, readOffset, writeOffset, size, )
      }

      static glCopyImageSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyImageSubData(srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei, ) -> () {
        let u: usize = glCopyImageSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,GLint,GLint,GLint,GLuint,GLenum,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, )
      }

      static glCopyNamedBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyNamedBufferSubData(readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glCopyNamedBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLintptr,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(readBuffer, writeBuffer, readOffset, writeOffset, size, )
      }

      static glCopyTexImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTexImage1D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint, ) -> () {
        let u: usize = glCopyTexImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, x, y, width, border, )
      }

      static glCopyTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint, ) -> () {
        let u: usize = glCopyTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLsizei,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, x, y, width, height, border, )
      }

      static glCopyTexSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTexSubImage1D(target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei, ) -> () {
        let u: usize = glCopyTexSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLint,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, x, y, width, )
      }

      static glCopyTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glCopyTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, x, y, width, height, )
      }

      static glCopyTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glCopyTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, zoffset, x, y, width, height, )
      }

      static glCopyTextureSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTextureSubImage1D(texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei, ) -> () {
        let u: usize = glCopyTextureSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, x, y, width, )
      }

      static glCopyTextureSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTextureSubImage2D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glCopyTextureSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, x, y, width, height, )
      }

      static glCopyTextureSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCopyTextureSubImage3D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glCopyTextureSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, x, y, width, height, )
      }

      static glCreateBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateBuffers(n: GLsizei, buffers: *mut GLuint, ) -> () {
        let u: usize = glCreateBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, buffers, )
      }

      static glCreateFramebuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateFramebuffers(n: GLsizei, framebuffers: *mut GLuint, ) -> () {
        let u: usize = glCreateFramebuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, framebuffers, )
      }

      static glCreateProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateProgram() -> GLuint {
        let u: usize = glCreateProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->GLuint = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glCreateProgramPipelines_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateProgramPipelines(n: GLsizei, pipelines: *mut GLuint, ) -> () {
        let u: usize = glCreateProgramPipelines_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, pipelines, )
      }

      static glCreateQueries_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateQueries(target: GLenum, n: GLsizei, ids: *mut GLuint, ) -> () {
        let u: usize = glCreateQueries_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, n, ids, )
      }

      static glCreateRenderbuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint, ) -> () {
        let u: usize = glCreateRenderbuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, renderbuffers, )
      }

      static glCreateSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateSamplers(n: GLsizei, samplers: *mut GLuint, ) -> () {
        let u: usize = glCreateSamplers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, samplers, )
      }

      static glCreateShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateShader(type_: GLenum, ) -> GLuint {
        let u: usize = glCreateShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(type_, )
      }

      static glCreateShaderProgramv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateShaderProgramv(type_: GLenum, count: GLsizei, strings: *const *const GLchar, ) -> GLuint {
        let u: usize = glCreateShaderProgramv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*const *const GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(type_, count, strings, )
      }

      static glCreateTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateTextures(target: GLenum, n: GLsizei, textures: *mut GLuint, ) -> () {
        let u: usize = glCreateTextures_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, n, textures, )
      }

      static glCreateTransformFeedbacks_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateTransformFeedbacks(n: GLsizei, ids: *mut GLuint, ) -> () {
        let u: usize = glCreateTransformFeedbacks_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, ids, )
      }

      static glCreateVertexArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCreateVertexArrays(n: GLsizei, arrays: *mut GLuint, ) -> () {
        let u: usize = glCreateVertexArrays_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, arrays, )
      }

      static glCullFace_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glCullFace(mode: GLenum, ) -> () {
        let u: usize = glCullFace_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, )
      }

      static glDebugMessageCallback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageCallback(callback: GLDEBUGPROC, userParam: *const void, ) -> () {
        let u: usize = glDebugMessageCallback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLDEBUGPROC,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(callback, userParam, )
      }

      static glDebugMessageCallbackARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageCallbackARB(callback: GLDEBUGPROCARB, userParam: *const void, ) -> () {
        let u: usize = glDebugMessageCallbackARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLDEBUGPROCARB,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(callback, userParam, )
      }

      static glDebugMessageCallbackKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageCallbackKHR(callback: GLDEBUGPROCKHR, userParam: *const void, ) -> () {
        let u: usize = glDebugMessageCallbackKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLDEBUGPROCKHR,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(callback, userParam, )
      }

      static glDebugMessageControl_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageControl(source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean, ) -> () {
        let u: usize = glDebugMessageControl_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLsizei,*const GLuint,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, severity, count, ids, enabled, )
      }

      static glDebugMessageControlARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageControlARB(source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean, ) -> () {
        let u: usize = glDebugMessageControlARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLsizei,*const GLuint,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, severity, count, ids, enabled, )
      }

      static glDebugMessageControlKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageControlKHR(source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean, ) -> () {
        let u: usize = glDebugMessageControlKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLsizei,*const GLuint,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, severity, count, ids, enabled, )
      }

      static glDebugMessageInsert_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageInsert(source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar, ) -> () {
        let u: usize = glDebugMessageInsert_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLenum,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, id, severity, length, buf, )
      }

      static glDebugMessageInsertARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageInsertARB(source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar, ) -> () {
        let u: usize = glDebugMessageInsertARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLenum,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, id, severity, length, buf, )
      }

      static glDebugMessageInsertKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDebugMessageInsertKHR(source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar, ) -> () {
        let u: usize = glDebugMessageInsertKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLenum,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, type_, id, severity, length, buf, )
      }

      static glDeleteBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteBuffers(n: GLsizei, buffers: *const GLuint, ) -> () {
        let u: usize = glDeleteBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, buffers, )
      }

      static glDeleteFramebuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteFramebuffers(n: GLsizei, framebuffers: *const GLuint, ) -> () {
        let u: usize = glDeleteFramebuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, framebuffers, )
      }

      static glDeleteProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteProgram(program: GLuint, ) -> () {
        let u: usize = glDeleteProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, )
      }

      static glDeleteProgramPipelines_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteProgramPipelines(n: GLsizei, pipelines: *const GLuint, ) -> () {
        let u: usize = glDeleteProgramPipelines_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, pipelines, )
      }

      static glDeleteQueries_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteQueries(n: GLsizei, ids: *const GLuint, ) -> () {
        let u: usize = glDeleteQueries_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, ids, )
      }

      static glDeleteRenderbuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteRenderbuffers(n: GLsizei, renderbuffers: *const GLuint, ) -> () {
        let u: usize = glDeleteRenderbuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, renderbuffers, )
      }

      static glDeleteSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteSamplers(count: GLsizei, samplers: *const GLuint, ) -> () {
        let u: usize = glDeleteSamplers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(count, samplers, )
      }

      static glDeleteShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteShader(shader: GLuint, ) -> () {
        let u: usize = glDeleteShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, )
      }

      static glDeleteSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteSync(sync: GLsync, ) -> () {
        let u: usize = glDeleteSync_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsync,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sync, )
      }

      static glDeleteTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteTextures(n: GLsizei, textures: *const GLuint, ) -> () {
        let u: usize = glDeleteTextures_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, textures, )
      }

      static glDeleteTransformFeedbacks_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteTransformFeedbacks(n: GLsizei, ids: *const GLuint, ) -> () {
        let u: usize = glDeleteTransformFeedbacks_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, ids, )
      }

      static glDeleteVertexArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDeleteVertexArrays(n: GLsizei, arrays: *const GLuint, ) -> () {
        let u: usize = glDeleteVertexArrays_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, arrays, )
      }

      static glDepthFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthFunc(func: GLenum, ) -> () {
        let u: usize = glDepthFunc_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(func, )
      }

      static glDepthMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthMask(flag: GLboolean, ) -> () {
        let u: usize = glDepthMask_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(flag, )
      }

      static glDepthRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthRange(n: GLdouble, f: GLdouble, ) -> () {
        let u: usize = glDepthRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, f, )
      }

      static glDepthRangeArrayv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthRangeArrayv(first: GLuint, count: GLsizei, v: *const GLdouble, ) -> () {
        let u: usize = glDepthRangeArrayv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, v, )
      }

      static glDepthRangeIndexed_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthRangeIndexed(index: GLuint, n: GLdouble, f: GLdouble, ) -> () {
        let u: usize = glDepthRangeIndexed_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, n, f, )
      }

      static glDepthRangef_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDepthRangef(n: GLfloat, f: GLfloat, ) -> () {
        let u: usize = glDepthRangef_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, f, )
      }

      static glDetachShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDetachShader(program: GLuint, shader: GLuint, ) -> () {
        let u: usize = glDetachShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shader, )
      }

      static glDisable_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDisable(cap: GLenum, ) -> () {
        let u: usize = glDisable_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(cap, )
      }

      static glDisableIndexedEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDisableIndexedEXT(target: GLenum, index: GLuint, ) -> () {
        let u: usize = glDisableIndexedEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glDisableVertexArrayAttrib_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDisableVertexArrayAttrib(vaobj: GLuint, index: GLuint, ) -> () {
        let u: usize = glDisableVertexArrayAttrib_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, index, )
      }

      static glDisableVertexAttribArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDisableVertexAttribArray(index: GLuint, ) -> () {
        let u: usize = glDisableVertexAttribArray_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, )
      }

      static glDisablei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDisablei(target: GLenum, index: GLuint, ) -> () {
        let u: usize = glDisablei_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glDispatchCompute_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDispatchCompute(num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint, ) -> () {
        let u: usize = glDispatchCompute_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(num_groups_x, num_groups_y, num_groups_z, )
      }

      static glDispatchComputeIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDispatchComputeIndirect(indirect: GLintptr, ) -> () {
        let u: usize = glDispatchComputeIndirect_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLintptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(indirect, )
      }

      static glDrawArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei, ) -> () {
        let u: usize = glDrawArrays_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, first, count, )
      }

      static glDrawArraysIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawArraysIndirect(mode: GLenum, indirect: *const void, ) -> () {
        let u: usize = glDrawArraysIndirect_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, indirect, )
      }

      static glDrawArraysInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, ) -> () {
        let u: usize = glDrawArraysInstanced_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, first, count, instancecount, )
      }

      static glDrawArraysInstancedARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawArraysInstancedARB(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei, ) -> () {
        let u: usize = glDrawArraysInstancedARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, first, count, primcount, )
      }

      static glDrawArraysInstancedBaseInstance_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawArraysInstancedBaseInstance(mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint, ) -> () {
        let u: usize = glDrawArraysInstancedBaseInstance_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLsizei,GLsizei,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, first, count, instancecount, baseinstance, )
      }

      static glDrawBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawBuffer(buf: GLenum, ) -> () {
        let u: usize = glDrawBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buf, )
      }

      static glDrawBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawBuffers(n: GLsizei, bufs: *const GLenum, ) -> () {
        let u: usize = glDrawBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, bufs, )
      }

      static glDrawElements_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElements(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, ) -> () {
        let u: usize = glDrawElements_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, )
      }

      static glDrawElementsBaseVertex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsBaseVertex(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, basevertex: GLint, ) -> () {
        let u: usize = glDrawElementsBaseVertex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, basevertex, )
      }

      static glDrawElementsIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsIndirect(mode: GLenum, type_: GLenum, indirect: *const void, ) -> () {
        let u: usize = glDrawElementsIndirect_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, type_, indirect, )
      }

      static glDrawElementsInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsInstanced(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, instancecount: GLsizei, ) -> () {
        let u: usize = glDrawElementsInstanced_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, instancecount, )
      }

      static glDrawElementsInstancedARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsInstancedARB(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, primcount: GLsizei, ) -> () {
        let u: usize = glDrawElementsInstancedARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, primcount, )
      }

      static glDrawElementsInstancedBaseInstance_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsInstancedBaseInstance(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, instancecount: GLsizei, baseinstance: GLuint, ) -> () {
        let u: usize = glDrawElementsInstancedBaseInstance_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLsizei,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, instancecount, baseinstance, )
      }

      static glDrawElementsInstancedBaseVertex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsInstancedBaseVertex(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, instancecount: GLsizei, basevertex: GLint, ) -> () {
        let u: usize = glDrawElementsInstancedBaseVertex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLsizei,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, instancecount, basevertex, )
      }

      static glDrawElementsInstancedBaseVertexBaseInstance_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint, ) -> () {
        let u: usize = glDrawElementsInstancedBaseVertexBaseInstance_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,*const void,GLsizei,GLint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, instancecount, basevertex, baseinstance, )
      }

      static glDrawRangeElements_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const void, ) -> () {
        let u: usize = glDrawRangeElements_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,GLsizei,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, start, end, count, type_, indices, )
      }

      static glDrawRangeElementsBaseVertex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawRangeElementsBaseVertex(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const void, basevertex: GLint, ) -> () {
        let u: usize = glDrawRangeElementsBaseVertex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,GLsizei,GLenum,*const void,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, start, end, count, type_, indices, basevertex, )
      }

      static glDrawTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawTransformFeedback(mode: GLenum, id: GLuint, ) -> () {
        let u: usize = glDrawTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, id, )
      }

      static glDrawTransformFeedbackInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawTransformFeedbackInstanced(mode: GLenum, id: GLuint, instancecount: GLsizei, ) -> () {
        let u: usize = glDrawTransformFeedbackInstanced_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, id, instancecount, )
      }

      static glDrawTransformFeedbackStream_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawTransformFeedbackStream(mode: GLenum, id: GLuint, stream: GLuint, ) -> () {
        let u: usize = glDrawTransformFeedbackStream_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, id, stream, )
      }

      static glDrawTransformFeedbackStreamInstanced_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glDrawTransformFeedbackStreamInstanced(mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei, ) -> () {
        let u: usize = glDrawTransformFeedbackStreamInstanced_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLuint,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, id, stream, instancecount, )
      }

      static glEnable_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEnable(cap: GLenum, ) -> () {
        let u: usize = glEnable_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(cap, )
      }

      static glEnableIndexedEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEnableIndexedEXT(target: GLenum, index: GLuint, ) -> () {
        let u: usize = glEnableIndexedEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glEnableVertexArrayAttrib_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEnableVertexArrayAttrib(vaobj: GLuint, index: GLuint, ) -> () {
        let u: usize = glEnableVertexArrayAttrib_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, index, )
      }

      static glEnableVertexAttribArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEnableVertexAttribArray(index: GLuint, ) -> () {
        let u: usize = glEnableVertexAttribArray_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, )
      }

      static glEnablei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEnablei(target: GLenum, index: GLuint, ) -> () {
        let u: usize = glEnablei_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glEndConditionalRender_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEndConditionalRender() -> () {
        let u: usize = glEndConditionalRender_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glEndQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEndQuery(target: GLenum, ) -> () {
        let u: usize = glEndQuery_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, )
      }

      static glEndQueryIndexed_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEndQueryIndexed(target: GLenum, index: GLuint, ) -> () {
        let u: usize = glEndQueryIndexed_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glEndTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glEndTransformFeedback() -> () {
        let u: usize = glEndTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glFenceSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFenceSync(condition: GLenum, flags: GLbitfield, ) -> GLsync {
        let u: usize = glFenceSync_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLbitfield,)->GLsync = unsafe { core::mem::transmute(u) };
        _func_p(condition, flags, )
      }

      static glFinish_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFinish() -> () {
        let u: usize = glFinish_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glFlush_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFlush() -> () {
        let u: usize = glFlush_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glFlushMappedBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFlushMappedBufferRange(target: GLenum, offset: GLintptr, length: GLsizeiptr, ) -> () {
        let u: usize = glFlushMappedBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, offset, length, )
      }

      static glFlushMappedNamedBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFlushMappedNamedBufferRange(buffer: GLuint, offset: GLintptr, length: GLsizeiptr, ) -> () {
        let u: usize = glFlushMappedNamedBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, offset, length, )
      }

      static glFramebufferParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferParameteri(target: GLenum, pname: GLenum, param: GLint, ) -> () {
        let u: usize = glFramebufferParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, param, )
      }

      static glFramebufferRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint, ) -> () {
        let u: usize = glFramebufferRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, renderbuffertarget, renderbuffer, )
      }

      static glFramebufferTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferTexture(target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, ) -> () {
        let u: usize = glFramebufferTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, texture, level, )
      }

      static glFramebufferTexture1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferTexture1D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, ) -> () {
        let u: usize = glFramebufferTexture1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, textarget, texture, level, )
      }

      static glFramebufferTexture2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, ) -> () {
        let u: usize = glFramebufferTexture2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, textarget, texture, level, )
      }

      static glFramebufferTexture3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferTexture3D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint, ) -> () {
        let u: usize = glFramebufferTexture3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLuint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, textarget, texture, level, zoffset, )
      }

      static glFramebufferTextureLayer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFramebufferTextureLayer(target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint, ) -> () {
        let u: usize = glFramebufferTextureLayer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, texture, level, layer, )
      }

      static glFrontFace_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glFrontFace(mode: GLenum, ) -> () {
        let u: usize = glFrontFace_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, )
      }

      static glGenBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenBuffers(n: GLsizei, buffers: *mut GLuint, ) -> () {
        let u: usize = glGenBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, buffers, )
      }

      static glGenFramebuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenFramebuffers(n: GLsizei, framebuffers: *mut GLuint, ) -> () {
        let u: usize = glGenFramebuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, framebuffers, )
      }

      static glGenProgramPipelines_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenProgramPipelines(n: GLsizei, pipelines: *mut GLuint, ) -> () {
        let u: usize = glGenProgramPipelines_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, pipelines, )
      }

      static glGenQueries_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenQueries(n: GLsizei, ids: *mut GLuint, ) -> () {
        let u: usize = glGenQueries_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, ids, )
      }

      static glGenRenderbuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint, ) -> () {
        let u: usize = glGenRenderbuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, renderbuffers, )
      }

      static glGenSamplers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenSamplers(count: GLsizei, samplers: *mut GLuint, ) -> () {
        let u: usize = glGenSamplers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(count, samplers, )
      }

      static glGenTextures_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenTextures(n: GLsizei, textures: *mut GLuint, ) -> () {
        let u: usize = glGenTextures_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, textures, )
      }

      static glGenTransformFeedbacks_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenTransformFeedbacks(n: GLsizei, ids: *mut GLuint, ) -> () {
        let u: usize = glGenTransformFeedbacks_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, ids, )
      }

      static glGenVertexArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenVertexArrays(n: GLsizei, arrays: *mut GLuint, ) -> () {
        let u: usize = glGenVertexArrays_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(n, arrays, )
      }

      static glGenerateMipmap_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenerateMipmap(target: GLenum, ) -> () {
        let u: usize = glGenerateMipmap_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, )
      }

      static glGenerateTextureMipmap_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGenerateTextureMipmap(texture: GLuint, ) -> () {
        let u: usize = glGenerateTextureMipmap_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, )
      }

      static glGetActiveAtomicCounterBufferiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveAtomicCounterBufferiv(program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetActiveAtomicCounterBufferiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, bufferIndex, pname, params, )
      }

      static glGetActiveAttrib_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveAttrib(program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar, ) -> () {
        let u: usize = glGetActiveAttrib_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*mut GLsizei,*mut GLint,*mut GLenum,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, index, bufSize, length, size, type_, name, )
      }

      static glGetActiveSubroutineName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveSubroutineName(program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar, ) -> () {
        let u: usize = glGetActiveSubroutineName_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, index, bufSize, length, name, )
      }

      static glGetActiveSubroutineUniformName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveSubroutineUniformName(program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar, ) -> () {
        let u: usize = glGetActiveSubroutineUniformName_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, index, bufSize, length, name, )
      }

      static glGetActiveSubroutineUniformiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveSubroutineUniformiv(program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint, ) -> () {
        let u: usize = glGetActiveSubroutineUniformiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, index, pname, values, )
      }

      static glGetActiveUniform_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveUniform(program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar, ) -> () {
        let u: usize = glGetActiveUniform_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*mut GLsizei,*mut GLint,*mut GLenum,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, index, bufSize, length, size, type_, name, )
      }

      static glGetActiveUniformBlockName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveUniformBlockName(program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar, ) -> () {
        let u: usize = glGetActiveUniformBlockName_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformBlockIndex, bufSize, length, uniformBlockName, )
      }

      static glGetActiveUniformBlockiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveUniformBlockiv(program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetActiveUniformBlockiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformBlockIndex, pname, params, )
      }

      static glGetActiveUniformName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveUniformName(program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar, ) -> () {
        let u: usize = glGetActiveUniformName_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformIndex, bufSize, length, uniformName, )
      }

      static glGetActiveUniformsiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetActiveUniformsiv(program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetActiveUniformsiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformCount, uniformIndices, pname, params, )
      }

      static glGetAttachedShaders_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetAttachedShaders(program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint, ) -> () {
        let u: usize = glGetAttachedShaders_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, maxCount, count, shaders, )
      }

      static glGetAttribLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetAttribLocation(program: GLuint, name: *const GLchar, ) -> GLint {
        let u: usize = glGetAttribLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, name, )
      }

      static glGetBooleanIndexedvEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBooleanIndexedvEXT(target: GLenum, index: GLuint, data: *mut GLboolean, ) -> () {
        let u: usize = glGetBooleanIndexedvEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetBooleani_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBooleani_v(target: GLenum, index: GLuint, data: *mut GLboolean, ) -> () {
        let u: usize = glGetBooleani_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetBooleanv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBooleanv(pname: GLenum, data: *mut GLboolean, ) -> () {
        let u: usize = glGetBooleanv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, data, )
      }

      static glGetBufferParameteri64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBufferParameteri64v(target: GLenum, pname: GLenum, params: *mut GLint64, ) -> () {
        let u: usize = glGetBufferParameteri64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetBufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetBufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetBufferPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBufferPointerv(target: GLenum, pname: GLenum, params: *mut *mut void, ) -> () {
        let u: usize = glGetBufferPointerv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut *mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetBufferSubData(target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut void, ) -> () {
        let u: usize = glGetBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLintptr,GLsizeiptr,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, offset, size, data, )
      }

      static glGetCompressedTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetCompressedTexImage(target: GLenum, level: GLint, img: *mut void, ) -> () {
        let u: usize = glGetCompressedTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, img, )
      }

      static glGetCompressedTextureImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetCompressedTextureImage(texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetCompressedTextureImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, bufSize, pixels, )
      }

      static glGetCompressedTextureSubImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetCompressedTextureSubImage(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetCompressedTextureSubImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels, )
      }

      static glGetDebugMessageLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetDebugMessageLog(count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar, ) -> GLuint {
        let u: usize = glGetDebugMessageLog_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLenum,*mut GLenum,*mut GLuint,*mut GLenum,*mut GLsizei,*mut GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(count, bufSize, sources, types, ids, severities, lengths, messageLog, )
      }

      static glGetDebugMessageLogARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetDebugMessageLogARB(count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar, ) -> GLuint {
        let u: usize = glGetDebugMessageLogARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLenum,*mut GLenum,*mut GLuint,*mut GLenum,*mut GLsizei,*mut GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(count, bufSize, sources, types, ids, severities, lengths, messageLog, )
      }

      static glGetDebugMessageLogKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetDebugMessageLogKHR(count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar, ) -> GLuint {
        let u: usize = glGetDebugMessageLogKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLenum,*mut GLenum,*mut GLuint,*mut GLenum,*mut GLsizei,*mut GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(count, bufSize, sources, types, ids, severities, lengths, messageLog, )
      }

      static glGetDoublei_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetDoublei_v(target: GLenum, index: GLuint, data: *mut GLdouble, ) -> () {
        let u: usize = glGetDoublei_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetDoublev_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetDoublev(pname: GLenum, data: *mut GLdouble, ) -> () {
        let u: usize = glGetDoublev_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, data, )
      }

      static glGetError_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetError() -> GLenum {
        let u: usize = glGetError_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->GLenum = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glGetFloati_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFloati_v(target: GLenum, index: GLuint, data: *mut GLfloat, ) -> () {
        let u: usize = glGetFloati_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetFloatv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFloatv(pname: GLenum, data: *mut GLfloat, ) -> () {
        let u: usize = glGetFloatv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, data, )
      }

      static glGetFragDataIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFragDataIndex(program: GLuint, name: *const GLchar, ) -> GLint {
        let u: usize = glGetFragDataIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, name, )
      }

      static glGetFragDataLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFragDataLocation(program: GLuint, name: *const GLchar, ) -> GLint {
        let u: usize = glGetFragDataLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, name, )
      }

      static glGetFramebufferAttachmentParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFramebufferAttachmentParameteriv(target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetFramebufferAttachmentParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, attachment, pname, params, )
      }

      static glGetFramebufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetFramebufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetFramebufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetGraphicsResetStatus_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetGraphicsResetStatus() -> GLenum {
        let u: usize = glGetGraphicsResetStatus_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->GLenum = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glGetInteger64i_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetInteger64i_v(target: GLenum, index: GLuint, data: *mut GLint64, ) -> () {
        let u: usize = glGetInteger64i_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetInteger64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetInteger64v(pname: GLenum, data: *mut GLint64, ) -> () {
        let u: usize = glGetInteger64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, data, )
      }

      static glGetIntegerIndexedvEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetIntegerIndexedvEXT(target: GLenum, index: GLuint, data: *mut GLint, ) -> () {
        let u: usize = glGetIntegerIndexedvEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetIntegeri_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetIntegeri_v(target: GLenum, index: GLuint, data: *mut GLint, ) -> () {
        let u: usize = glGetIntegeri_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, data, )
      }

      static glGetIntegerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetIntegerv(pname: GLenum, data: *mut GLint, ) -> () {
        let u: usize = glGetIntegerv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, data, )
      }

      static glGetInternalformati64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetInternalformati64v(target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64, ) -> () {
        let u: usize = glGetInternalformati64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLsizei,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, pname, count, params, )
      }

      static glGetInternalformativ_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetInternalformativ(target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint, ) -> () {
        let u: usize = glGetInternalformativ_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLsizei,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, pname, count, params, )
      }

      static glGetMultisamplefv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetMultisamplefv(pname: GLenum, index: GLuint, val: *mut GLfloat, ) -> () {
        let u: usize = glGetMultisamplefv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, index, val, )
      }

      static glGetNamedBufferParameteri64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedBufferParameteri64v(buffer: GLuint, pname: GLenum, params: *mut GLint64, ) -> () {
        let u: usize = glGetNamedBufferParameteri64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, pname, params, )
      }

      static glGetNamedBufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedBufferParameteriv(buffer: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetNamedBufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, pname, params, )
      }

      static glGetNamedBufferPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedBufferPointerv(buffer: GLuint, pname: GLenum, params: *mut *mut void, ) -> () {
        let u: usize = glGetNamedBufferPointerv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut *mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, pname, params, )
      }

      static glGetNamedBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedBufferSubData(buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut void, ) -> () {
        let u: usize = glGetNamedBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLintptr,GLsizeiptr,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, offset, size, data, )
      }

      static glGetNamedFramebufferAttachmentParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetNamedFramebufferAttachmentParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, attachment, pname, params, )
      }

      static glGetNamedFramebufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedFramebufferParameteriv(framebuffer: GLuint, pname: GLenum, param: *mut GLint, ) -> () {
        let u: usize = glGetNamedFramebufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, pname, param, )
      }

      static glGetNamedRenderbufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetNamedRenderbufferParameteriv(renderbuffer: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetNamedRenderbufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(renderbuffer, pname, params, )
      }

      static glGetObjectLabel_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetObjectLabel(identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar, ) -> () {
        let u: usize = glGetObjectLabel_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(identifier, name, bufSize, length, label, )
      }

      static glGetObjectLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetObjectLabelKHR(identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar, ) -> () {
        let u: usize = glGetObjectLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(identifier, name, bufSize, length, label, )
      }

      static glGetObjectPtrLabel_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetObjectPtrLabel(ptr: *const void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar, ) -> () {
        let u: usize = glGetObjectPtrLabel_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(*const void,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(ptr, bufSize, length, label, )
      }

      static glGetObjectPtrLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetObjectPtrLabelKHR(ptr: *const void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar, ) -> () {
        let u: usize = glGetObjectPtrLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(*const void,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(ptr, bufSize, length, label, )
      }

      static glGetPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetPointerv(pname: GLenum, params: *mut *mut void, ) -> () {
        let u: usize = glGetPointerv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut *mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, params, )
      }

      static glGetPointervKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetPointervKHR(pname: GLenum, params: *mut *mut void, ) -> () {
        let u: usize = glGetPointervKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*mut *mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, params, )
      }

      static glGetProgramBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramBinary(program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut void, ) -> () {
        let u: usize = glGetProgramBinary_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLenum,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, bufSize, length, binaryFormat, binary, )
      }

      static glGetProgramInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramInfoLog(program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar, ) -> () {
        let u: usize = glGetProgramInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, bufSize, length, infoLog, )
      }

      static glGetProgramInterfaceiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramInterfaceiv(program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetProgramInterfaceiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, pname, params, )
      }

      static glGetProgramPipelineInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramPipelineInfoLog(pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar, ) -> () {
        let u: usize = glGetProgramPipelineInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, bufSize, length, infoLog, )
      }

      static glGetProgramPipelineiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramPipelineiv(pipeline: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetProgramPipelineiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, pname, params, )
      }

      static glGetProgramResourceIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramResourceIndex(program: GLuint, programInterface: GLenum, name: *const GLchar, ) -> GLuint {
        let u: usize = glGetProgramResourceIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, name, )
      }

      static glGetProgramResourceLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramResourceLocation(program: GLuint, programInterface: GLenum, name: *const GLchar, ) -> GLint {
        let u: usize = glGetProgramResourceLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, name, )
      }

      static glGetProgramResourceLocationIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramResourceLocationIndex(program: GLuint, programInterface: GLenum, name: *const GLchar, ) -> GLint {
        let u: usize = glGetProgramResourceLocationIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, name, )
      }

      static glGetProgramResourceName_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramResourceName(program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar, ) -> () {
        let u: usize = glGetProgramResourceName_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, index, bufSize, length, name, )
      }

      static glGetProgramResourceiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramResourceiv(program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint, ) -> () {
        let u: usize = glGetProgramResourceiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLsizei,*const GLenum,GLsizei,*mut GLsizei,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, programInterface, index, propCount, props, count, length, params, )
      }

      static glGetProgramStageiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramStageiv(program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint, ) -> () {
        let u: usize = glGetProgramStageiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, pname, values, )
      }

      static glGetProgramiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetProgramiv(program: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetProgramiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, pname, params, )
      }

      static glGetQueryBufferObjecti64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryBufferObjecti64v(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr, ) -> () {
        let u: usize = glGetQueryBufferObjecti64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,GLintptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, buffer, pname, offset, )
      }

      static glGetQueryBufferObjectiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryBufferObjectiv(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr, ) -> () {
        let u: usize = glGetQueryBufferObjectiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,GLintptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, buffer, pname, offset, )
      }

      static glGetQueryBufferObjectui64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryBufferObjectui64v(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr, ) -> () {
        let u: usize = glGetQueryBufferObjectui64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,GLintptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, buffer, pname, offset, )
      }

      static glGetQueryBufferObjectuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryBufferObjectuiv(id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr, ) -> () {
        let u: usize = glGetQueryBufferObjectuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,GLintptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, buffer, pname, offset, )
      }

      static glGetQueryIndexediv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryIndexediv(target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetQueryIndexediv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, index, pname, params, )
      }

      static glGetQueryObjecti64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryObjecti64v(id: GLuint, pname: GLenum, params: *mut GLint64, ) -> () {
        let u: usize = glGetQueryObjecti64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, pname, params, )
      }

      static glGetQueryObjectiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryObjectiv(id: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetQueryObjectiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, pname, params, )
      }

      static glGetQueryObjectui64v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryObjectui64v(id: GLuint, pname: GLenum, params: *mut GLuint64, ) -> () {
        let u: usize = glGetQueryObjectui64v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLuint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, pname, params, )
      }

      static glGetQueryObjectuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryObjectuiv(id: GLuint, pname: GLenum, params: *mut GLuint, ) -> () {
        let u: usize = glGetQueryObjectuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, pname, params, )
      }

      static glGetQueryiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetQueryiv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetQueryiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetRenderbufferParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetRenderbufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetRenderbufferParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetSamplerParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSamplerParameterIiv(sampler: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetSamplerParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, params, )
      }

      static glGetSamplerParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSamplerParameterIuiv(sampler: GLuint, pname: GLenum, params: *mut GLuint, ) -> () {
        let u: usize = glGetSamplerParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, params, )
      }

      static glGetSamplerParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSamplerParameterfv(sampler: GLuint, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetSamplerParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, params, )
      }

      static glGetSamplerParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSamplerParameteriv(sampler: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetSamplerParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, params, )
      }

      static glGetShaderInfoLog_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetShaderInfoLog(shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar, ) -> () {
        let u: usize = glGetShaderInfoLog_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, bufSize, length, infoLog, )
      }

      static glGetShaderPrecisionFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint, ) -> () {
        let u: usize = glGetShaderPrecisionFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shadertype, precisiontype, range, precision, )
      }

      static glGetShaderSource_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetShaderSource(shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar, ) -> () {
        let u: usize = glGetShaderSource_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*mut GLsizei,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, bufSize, length, source, )
      }

      static glGetShaderiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetShaderiv(shader: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetShaderiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, pname, params, )
      }

      static glGetString_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetString(name: GLenum, ) -> *const GLubyte {
        let u: usize = glGetString_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->*const GLubyte = unsafe { core::mem::transmute(u) };
        _func_p(name, )
      }

      static glGetStringi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetStringi(name: GLenum, index: GLuint, ) -> *const GLubyte {
        let u: usize = glGetStringi_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->*const GLubyte = unsafe { core::mem::transmute(u) };
        _func_p(name, index, )
      }

      static glGetSubroutineIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSubroutineIndex(program: GLuint, shadertype: GLenum, name: *const GLchar, ) -> GLuint {
        let u: usize = glGetSubroutineIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, name, )
      }

      static glGetSubroutineUniformLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSubroutineUniformLocation(program: GLuint, shadertype: GLenum, name: *const GLchar, ) -> GLint {
        let u: usize = glGetSubroutineUniformLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, shadertype, name, )
      }

      static glGetSynciv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetSynciv(sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint, ) -> () {
        let u: usize = glGetSynciv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsync,GLenum,GLsizei,*mut GLsizei,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sync, pname, count, length, values, )
      }

      static glGetTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexImage(target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut void, ) -> () {
        let u: usize = glGetTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLenum,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, format, type_, pixels, )
      }

      static glGetTexLevelParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexLevelParameterfv(target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetTexLevelParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, pname, params, )
      }

      static glGetTexLevelParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexLevelParameteriv(target: GLenum, level: GLint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTexLevelParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, pname, params, )
      }

      static glGetTexParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexParameterIiv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTexParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetTexParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexParameterIuiv(target: GLenum, pname: GLenum, params: *mut GLuint, ) -> () {
        let u: usize = glGetTexParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetTexParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexParameterfv(target: GLenum, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetTexParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetTexParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTexParameteriv(target: GLenum, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTexParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glGetTextureImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureImage(texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetTextureImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLenum,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, format, type_, bufSize, pixels, )
      }

      static glGetTextureLevelParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureLevelParameterfv(texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetTextureLevelParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, pname, params, )
      }

      static glGetTextureLevelParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureLevelParameteriv(texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTextureLevelParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, pname, params, )
      }

      static glGetTextureParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureParameterIiv(texture: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTextureParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glGetTextureParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureParameterIuiv(texture: GLuint, pname: GLenum, params: *mut GLuint, ) -> () {
        let u: usize = glGetTextureParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glGetTextureParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureParameterfv(texture: GLuint, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetTextureParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glGetTextureParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureParameteriv(texture: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetTextureParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glGetTextureSubImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTextureSubImage(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetTextureSubImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels, )
      }

      static glGetTransformFeedbackVarying_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTransformFeedbackVarying(program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar, ) -> () {
        let u: usize = glGetTransformFeedbackVarying_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*mut GLsizei,*mut GLsizei,*mut GLenum,*mut GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, index, bufSize, length, size, type_, name, )
      }

      static glGetTransformFeedbacki64_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTransformFeedbacki64_v(xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64, ) -> () {
        let u: usize = glGetTransformFeedbacki64_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(xfb, pname, index, param, )
      }

      static glGetTransformFeedbacki_v_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTransformFeedbacki_v(xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint, ) -> () {
        let u: usize = glGetTransformFeedbacki_v_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(xfb, pname, index, param, )
      }

      static glGetTransformFeedbackiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetTransformFeedbackiv(xfb: GLuint, pname: GLenum, param: *mut GLint, ) -> () {
        let u: usize = glGetTransformFeedbackiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(xfb, pname, param, )
      }

      static glGetUniformBlockIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformBlockIndex(program: GLuint, uniformBlockName: *const GLchar, ) -> GLuint {
        let u: usize = glGetUniformBlockIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,)->GLuint = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformBlockName, )
      }

      static glGetUniformIndices_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformIndices(program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint, ) -> () {
        let u: usize = glGetUniformIndices_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const *const GLchar,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformCount, uniformNames, uniformIndices, )
      }

      static glGetUniformLocation_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformLocation(program: GLuint, name: *const GLchar, ) -> GLint {
        let u: usize = glGetUniformLocation_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,)->GLint = unsafe { core::mem::transmute(u) };
        _func_p(program, name, )
      }

      static glGetUniformSubroutineuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformSubroutineuiv(shadertype: GLenum, location: GLint, params: *mut GLuint, ) -> () {
        let u: usize = glGetUniformSubroutineuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shadertype, location, params, )
      }

      static glGetUniformdv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformdv(program: GLuint, location: GLint, params: *mut GLdouble, ) -> () {
        let u: usize = glGetUniformdv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, params, )
      }

      static glGetUniformfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformfv(program: GLuint, location: GLint, params: *mut GLfloat, ) -> () {
        let u: usize = glGetUniformfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, params, )
      }

      static glGetUniformiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformiv(program: GLuint, location: GLint, params: *mut GLint, ) -> () {
        let u: usize = glGetUniformiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, params, )
      }

      static glGetUniformuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetUniformuiv(program: GLuint, location: GLint, params: *mut GLuint, ) -> () {
        let u: usize = glGetUniformuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, params, )
      }

      static glGetVertexArrayIndexed64iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexArrayIndexed64iv(vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64, ) -> () {
        let u: usize = glGetVertexArrayIndexed64iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,*mut GLint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, index, pname, param, )
      }

      static glGetVertexArrayIndexediv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexArrayIndexediv(vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint, ) -> () {
        let u: usize = glGetVertexArrayIndexediv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, index, pname, param, )
      }

      static glGetVertexArrayiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexArrayiv(vaobj: GLuint, pname: GLenum, param: *mut GLint, ) -> () {
        let u: usize = glGetVertexArrayiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, pname, param, )
      }

      static glGetVertexAttribIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribIiv(index: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetVertexAttribIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetVertexAttribIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribIuiv(index: GLuint, pname: GLenum, params: *mut GLuint, ) -> () {
        let u: usize = glGetVertexAttribIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetVertexAttribLdv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribLdv(index: GLuint, pname: GLenum, params: *mut GLdouble, ) -> () {
        let u: usize = glGetVertexAttribLdv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetVertexAttribPointerv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribPointerv(index: GLuint, pname: GLenum, pointer: *mut *mut void, ) -> () {
        let u: usize = glGetVertexAttribPointerv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut *mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, pointer, )
      }

      static glGetVertexAttribdv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribdv(index: GLuint, pname: GLenum, params: *mut GLdouble, ) -> () {
        let u: usize = glGetVertexAttribdv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetVertexAttribfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribfv(index: GLuint, pname: GLenum, params: *mut GLfloat, ) -> () {
        let u: usize = glGetVertexAttribfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetVertexAttribiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetVertexAttribiv(index: GLuint, pname: GLenum, params: *mut GLint, ) -> () {
        let u: usize = glGetVertexAttribiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, pname, params, )
      }

      static glGetnCompressedTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnCompressedTexImage(target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetnCompressedTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, lod, bufSize, pixels, )
      }

      static glGetnTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnTexImage(target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut void, ) -> () {
        let u: usize = glGetnTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLenum,GLenum,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, format, type_, bufSize, pixels, )
      }

      static glGetnUniformdv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnUniformdv(program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble, ) -> () {
        let u: usize = glGetnUniformdv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*mut GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, bufSize, params, )
      }

      static glGetnUniformfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnUniformfv(program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat, ) -> () {
        let u: usize = glGetnUniformfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*mut GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, bufSize, params, )
      }

      static glGetnUniformiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnUniformiv(program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint, ) -> () {
        let u: usize = glGetnUniformiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*mut GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, bufSize, params, )
      }

      static glGetnUniformuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glGetnUniformuiv(program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint, ) -> () {
        let u: usize = glGetnUniformuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*mut GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, bufSize, params, )
      }

      static glHint_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glHint(target: GLenum, mode: GLenum, ) -> () {
        let u: usize = glHint_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, mode, )
      }

      static glInvalidateBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateBufferData(buffer: GLuint, ) -> () {
        let u: usize = glInvalidateBufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, )
      }

      static glInvalidateBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateBufferSubData(buffer: GLuint, offset: GLintptr, length: GLsizeiptr, ) -> () {
        let u: usize = glInvalidateBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, offset, length, )
      }

      static glInvalidateFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateFramebuffer(target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, ) -> () {
        let u: usize = glInvalidateFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*const GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, numAttachments, attachments, )
      }

      static glInvalidateNamedFramebufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateNamedFramebufferData(framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, ) -> () {
        let u: usize = glInvalidateNamedFramebufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, numAttachments, attachments, )
      }

      static glInvalidateNamedFramebufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateNamedFramebufferSubData(framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glInvalidateNamedFramebufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLenum,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, numAttachments, attachments, x, y, width, height, )
      }

      static glInvalidateSubFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateSubFramebuffer(target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glInvalidateSubFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*const GLenum,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, numAttachments, attachments, x, y, width, height, )
      }

      static glInvalidateTexImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateTexImage(texture: GLuint, level: GLint, ) -> () {
        let u: usize = glInvalidateTexImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, )
      }

      static glInvalidateTexSubImage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glInvalidateTexSubImage(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, ) -> () {
        let u: usize = glInvalidateTexSubImage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, )
      }

      static glIsBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsBuffer(buffer: GLuint, ) -> GLboolean {
        let u: usize = glIsBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(buffer, )
      }

      static glIsEnabled_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsEnabled(cap: GLenum, ) -> GLboolean {
        let u: usize = glIsEnabled_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(cap, )
      }

      static glIsEnabledIndexedEXT_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsEnabledIndexedEXT(target: GLenum, index: GLuint, ) -> GLboolean {
        let u: usize = glIsEnabledIndexedEXT_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glIsEnabledi_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsEnabledi(target: GLenum, index: GLuint, ) -> GLboolean {
        let u: usize = glIsEnabledi_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(target, index, )
      }

      static glIsFramebuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsFramebuffer(framebuffer: GLuint, ) -> GLboolean {
        let u: usize = glIsFramebuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, )
      }

      static glIsProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsProgram(program: GLuint, ) -> GLboolean {
        let u: usize = glIsProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(program, )
      }

      static glIsProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsProgramPipeline(pipeline: GLuint, ) -> GLboolean {
        let u: usize = glIsProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, )
      }

      static glIsQuery_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsQuery(id: GLuint, ) -> GLboolean {
        let u: usize = glIsQuery_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(id, )
      }

      static glIsRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsRenderbuffer(renderbuffer: GLuint, ) -> GLboolean {
        let u: usize = glIsRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(renderbuffer, )
      }

      static glIsSampler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsSampler(sampler: GLuint, ) -> GLboolean {
        let u: usize = glIsSampler_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(sampler, )
      }

      static glIsShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsShader(shader: GLuint, ) -> GLboolean {
        let u: usize = glIsShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(shader, )
      }

      static glIsSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsSync(sync: GLsync, ) -> GLboolean {
        let u: usize = glIsSync_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsync,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(sync, )
      }

      static glIsTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsTexture(texture: GLuint, ) -> GLboolean {
        let u: usize = glIsTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(texture, )
      }

      static glIsTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsTransformFeedback(id: GLuint, ) -> GLboolean {
        let u: usize = glIsTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(id, )
      }

      static glIsVertexArray_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glIsVertexArray(array: GLuint, ) -> GLboolean {
        let u: usize = glIsVertexArray_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(array, )
      }

      static glLineWidth_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glLineWidth(width: GLfloat, ) -> () {
        let u: usize = glLineWidth_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(width, )
      }

      static glLinkProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glLinkProgram(program: GLuint, ) -> () {
        let u: usize = glLinkProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, )
      }

      static glLogicOp_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glLogicOp(opcode: GLenum, ) -> () {
        let u: usize = glLogicOp_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(opcode, )
      }

      static glMapBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMapBuffer(target: GLenum, access: GLenum, ) -> *mut void {
        let u: usize = glMapBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->*mut void = unsafe { core::mem::transmute(u) };
        _func_p(target, access, )
      }

      static glMapBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMapBufferRange(target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield, ) -> *mut void {
        let u: usize = glMapBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLintptr,GLsizeiptr,GLbitfield,)->*mut void = unsafe { core::mem::transmute(u) };
        _func_p(target, offset, length, access, )
      }

      static glMapNamedBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMapNamedBuffer(buffer: GLuint, access: GLenum, ) -> *mut void {
        let u: usize = glMapNamedBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->*mut void = unsafe { core::mem::transmute(u) };
        _func_p(buffer, access, )
      }

      static glMapNamedBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMapNamedBufferRange(buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield, ) -> *mut void {
        let u: usize = glMapNamedBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLintptr,GLsizeiptr,GLbitfield,)->*mut void = unsafe { core::mem::transmute(u) };
        _func_p(buffer, offset, length, access, )
      }

      static glMaxShaderCompilerThreadsARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMaxShaderCompilerThreadsARB(count: GLuint, ) -> () {
        let u: usize = glMaxShaderCompilerThreadsARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(count, )
      }

      static glMaxShaderCompilerThreadsKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMaxShaderCompilerThreadsKHR(count: GLuint, ) -> () {
        let u: usize = glMaxShaderCompilerThreadsKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(count, )
      }

      static glMemoryBarrier_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMemoryBarrier(barriers: GLbitfield, ) -> () {
        let u: usize = glMemoryBarrier_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(barriers, )
      }

      static glMemoryBarrierByRegion_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMemoryBarrierByRegion(barriers: GLbitfield, ) -> () {
        let u: usize = glMemoryBarrierByRegion_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(barriers, )
      }

      static glMinSampleShading_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMinSampleShading(value: GLfloat, ) -> () {
        let u: usize = glMinSampleShading_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(value, )
      }

      static glMultiDrawArrays_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawArrays(mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei, ) -> () {
        let u: usize = glMultiDrawArrays_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLint,*const GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, first, count, drawcount, )
      }

      static glMultiDrawArraysIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawArraysIndirect(mode: GLenum, indirect: *const void, drawcount: GLsizei, stride: GLsizei, ) -> () {
        let u: usize = glMultiDrawArraysIndirect_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const void,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, indirect, drawcount, stride, )
      }

      static glMultiDrawArraysIndirectCount_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawArraysIndirectCount(mode: GLenum, indirect: *const void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei, ) -> () {
        let u: usize = glMultiDrawArraysIndirectCount_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const void,GLintptr,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, indirect, drawcount, maxdrawcount, stride, )
      }

      static glMultiDrawElements_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawElements(mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const void, drawcount: GLsizei, ) -> () {
        let u: usize = glMultiDrawElements_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLsizei,GLenum,*const *const void,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, drawcount, )
      }

      static glMultiDrawElementsBaseVertex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawElementsBaseVertex(mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const void, drawcount: GLsizei, basevertex: *const GLint, ) -> () {
        let u: usize = glMultiDrawElementsBaseVertex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLsizei,GLenum,*const *const void,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, count, type_, indices, drawcount, basevertex, )
      }

      static glMultiDrawElementsIndirect_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawElementsIndirect(mode: GLenum, type_: GLenum, indirect: *const void, drawcount: GLsizei, stride: GLsizei, ) -> () {
        let u: usize = glMultiDrawElementsIndirect_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const void,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, type_, indirect, drawcount, stride, )
      }

      static glMultiDrawElementsIndirectCount_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glMultiDrawElementsIndirectCount(mode: GLenum, type_: GLenum, indirect: *const void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei, ) -> () {
        let u: usize = glMultiDrawElementsIndirectCount_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const void,GLintptr,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, type_, indirect, drawcount, maxdrawcount, stride, )
      }

      static glNamedBufferData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedBufferData(buffer: GLuint, size: GLsizeiptr, data: *const void, usage: GLenum, ) -> () {
        let u: usize = glNamedBufferData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizeiptr,*const void,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, size, data, usage, )
      }

      static glNamedBufferStorage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedBufferStorage(buffer: GLuint, size: GLsizeiptr, data: *const void, flags: GLbitfield, ) -> () {
        let u: usize = glNamedBufferStorage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizeiptr,*const void,GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, size, data, flags, )
      }

      static glNamedBufferSubData_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedBufferSubData(buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const void, ) -> () {
        let u: usize = glNamedBufferSubData_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLintptr,GLsizeiptr,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(buffer, offset, size, data, )
      }

      static glNamedFramebufferDrawBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferDrawBuffer(framebuffer: GLuint, buf: GLenum, ) -> () {
        let u: usize = glNamedFramebufferDrawBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, buf, )
      }

      static glNamedFramebufferDrawBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferDrawBuffers(framebuffer: GLuint, n: GLsizei, bufs: *const GLenum, ) -> () {
        let u: usize = glNamedFramebufferDrawBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, n, bufs, )
      }

      static glNamedFramebufferParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferParameteri(framebuffer: GLuint, pname: GLenum, param: GLint, ) -> () {
        let u: usize = glNamedFramebufferParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, pname, param, )
      }

      static glNamedFramebufferReadBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferReadBuffer(framebuffer: GLuint, src: GLenum, ) -> () {
        let u: usize = glNamedFramebufferReadBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, src, )
      }

      static glNamedFramebufferRenderbuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferRenderbuffer(framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint, ) -> () {
        let u: usize = glNamedFramebufferRenderbuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, attachment, renderbuffertarget, renderbuffer, )
      }

      static glNamedFramebufferTexture_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferTexture(framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, ) -> () {
        let u: usize = glNamedFramebufferTexture_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, attachment, texture, level, )
      }

      static glNamedFramebufferTextureLayer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedFramebufferTextureLayer(framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint, ) -> () {
        let u: usize = glNamedFramebufferTextureLayer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(framebuffer, attachment, texture, level, layer, )
      }

      static glNamedRenderbufferStorage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedRenderbufferStorage(renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glNamedRenderbufferStorage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(renderbuffer, internalformat, width, height, )
      }

      static glNamedRenderbufferStorageMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glNamedRenderbufferStorageMultisample(renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glNamedRenderbufferStorageMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(renderbuffer, samples, internalformat, width, height, )
      }

      static glObjectLabel_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glObjectLabel(identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar, ) -> () {
        let u: usize = glObjectLabel_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(identifier, name, length, label, )
      }

      static glObjectLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glObjectLabelKHR(identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar, ) -> () {
        let u: usize = glObjectLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(identifier, name, length, label, )
      }

      static glObjectPtrLabel_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glObjectPtrLabel(ptr: *const void, length: GLsizei, label: *const GLchar, ) -> () {
        let u: usize = glObjectPtrLabel_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(*const void,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(ptr, length, label, )
      }

      static glObjectPtrLabelKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glObjectPtrLabelKHR(ptr: *const void, length: GLsizei, label: *const GLchar, ) -> () {
        let u: usize = glObjectPtrLabelKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(*const void,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(ptr, length, label, )
      }

      static glPatchParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPatchParameterfv(pname: GLenum, values: *const GLfloat, ) -> () {
        let u: usize = glPatchParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, values, )
      }

      static glPatchParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPatchParameteri(pname: GLenum, value: GLint, ) -> () {
        let u: usize = glPatchParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, value, )
      }

      static glPauseTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPauseTransformFeedback() -> () {
        let u: usize = glPauseTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glPixelStoref_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPixelStoref(pname: GLenum, param: GLfloat, ) -> () {
        let u: usize = glPixelStoref_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, param, )
      }

      static glPixelStorei_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPixelStorei(pname: GLenum, param: GLint, ) -> () {
        let u: usize = glPixelStorei_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, param, )
      }

      static glPointParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPointParameterf(pname: GLenum, param: GLfloat, ) -> () {
        let u: usize = glPointParameterf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, param, )
      }

      static glPointParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPointParameterfv(pname: GLenum, params: *const GLfloat, ) -> () {
        let u: usize = glPointParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, params, )
      }

      static glPointParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPointParameteri(pname: GLenum, param: GLint, ) -> () {
        let u: usize = glPointParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, param, )
      }

      static glPointParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPointParameteriv(pname: GLenum, params: *const GLint, ) -> () {
        let u: usize = glPointParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pname, params, )
      }

      static glPointSize_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPointSize(size: GLfloat, ) -> () {
        let u: usize = glPointSize_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(size, )
      }

      static glPolygonMode_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPolygonMode(face: GLenum, mode: GLenum, ) -> () {
        let u: usize = glPolygonMode_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(face, mode, )
      }

      static glPolygonOffset_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPolygonOffset(factor: GLfloat, units: GLfloat, ) -> () {
        let u: usize = glPolygonOffset_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(factor, units, )
      }

      static glPolygonOffsetClamp_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPolygonOffsetClamp(factor: GLfloat, units: GLfloat, clamp: GLfloat, ) -> () {
        let u: usize = glPolygonOffsetClamp_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(factor, units, clamp, )
      }

      static glPopDebugGroup_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPopDebugGroup() -> () {
        let u: usize = glPopDebugGroup_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glPopDebugGroupKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPopDebugGroupKHR() -> () {
        let u: usize = glPopDebugGroupKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glPrimitiveRestartIndex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPrimitiveRestartIndex(index: GLuint, ) -> () {
        let u: usize = glPrimitiveRestartIndex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, )
      }

      static glProgramBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramBinary(program: GLuint, binaryFormat: GLenum, binary: *const void, length: GLsizei, ) -> () {
        let u: usize = glProgramBinary_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const void,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, binaryFormat, binary, length, )
      }

      static glProgramParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramParameteri(program: GLuint, pname: GLenum, value: GLint, ) -> () {
        let u: usize = glProgramParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, pname, value, )
      }

      static glProgramUniform1d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1d(program: GLuint, location: GLint, v0: GLdouble, ) -> () {
        let u: usize = glProgramUniform1d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, )
      }

      static glProgramUniform1dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1dv(program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniform1dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1f(program: GLuint, location: GLint, v0: GLfloat, ) -> () {
        let u: usize = glProgramUniform1f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, )
      }

      static glProgramUniform1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniform1fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform1i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1i(program: GLuint, location: GLint, v0: GLint, ) -> () {
        let u: usize = glProgramUniform1i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, )
      }

      static glProgramUniform1iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glProgramUniform1iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1ui(program: GLuint, location: GLint, v0: GLuint, ) -> () {
        let u: usize = glProgramUniform1ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, )
      }

      static glProgramUniform1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform1uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glProgramUniform1uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform2d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2d(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, ) -> () {
        let u: usize = glProgramUniform2d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, )
      }

      static glProgramUniform2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2dv(program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniform2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, ) -> () {
        let u: usize = glProgramUniform2f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, )
      }

      static glProgramUniform2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniform2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform2i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2i(program: GLuint, location: GLint, v0: GLint, v1: GLint, ) -> () {
        let u: usize = glProgramUniform2i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, )
      }

      static glProgramUniform2iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glProgramUniform2iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, ) -> () {
        let u: usize = glProgramUniform2ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, )
      }

      static glProgramUniform2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform2uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glProgramUniform2uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform3d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3d(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, ) -> () {
        let u: usize = glProgramUniform3d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, )
      }

      static glProgramUniform3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3dv(program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniform3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, ) -> () {
        let u: usize = glProgramUniform3f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, )
      }

      static glProgramUniform3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniform3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform3i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3i(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, ) -> () {
        let u: usize = glProgramUniform3i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, )
      }

      static glProgramUniform3iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glProgramUniform3iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, ) -> () {
        let u: usize = glProgramUniform3ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, )
      }

      static glProgramUniform3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform3uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glProgramUniform3uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform4d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4d(program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble, ) -> () {
        let u: usize = glProgramUniform4d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLdouble,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, v3, )
      }

      static glProgramUniform4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4dv(program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniform4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat, ) -> () {
        let u: usize = glProgramUniform4f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, v3, )
      }

      static glProgramUniform4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4fv(program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniform4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4i(program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint, ) -> () {
        let u: usize = glProgramUniform4i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, v3, )
      }

      static glProgramUniform4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4iv(program: GLuint, location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glProgramUniform4iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniform4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint, ) -> () {
        let u: usize = glProgramUniform4ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLuint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, v0, v1, v2, v3, )
      }

      static glProgramUniform4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniform4uiv(program: GLuint, location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glProgramUniform4uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, value, )
      }

      static glProgramUniformMatrix2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix2x3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2x3dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix2x3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix2x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2x3fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix2x3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix2x4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2x4dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix2x4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix2x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix2x4fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix2x4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3x2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3x2dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix3x2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3x2fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix3x2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3x4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3x4dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix3x4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix3x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix3x4fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix3x4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4x2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4x2dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix4x2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4x2fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix4x2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4x3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4x3dv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glProgramUniformMatrix4x3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProgramUniformMatrix4x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProgramUniformMatrix4x3fv(program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glProgramUniformMatrix4x3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, location, count, transpose, value, )
      }

      static glProvokingVertex_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glProvokingVertex(mode: GLenum, ) -> () {
        let u: usize = glProvokingVertex_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mode, )
      }

      static glPushDebugGroup_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPushDebugGroup(source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar, ) -> () {
        let u: usize = glPushDebugGroup_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, id, length, message, )
      }

      static glPushDebugGroupKHR_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glPushDebugGroupKHR(source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar, ) -> () {
        let u: usize = glPushDebugGroupKHR_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,GLsizei,*const GLchar,)->() = unsafe { core::mem::transmute(u) };
        _func_p(source, id, length, message, )
      }

      static glQueryCounter_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glQueryCounter(id: GLuint, target: GLenum, ) -> () {
        let u: usize = glQueryCounter_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(id, target, )
      }

      static glReadBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glReadBuffer(src: GLenum, ) -> () {
        let u: usize = glReadBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(src, )
      }

      static glReadPixels_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glReadPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut void, ) -> () {
        let u: usize = glReadPixels_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(x, y, width, height, format, type_, pixels, )
      }

      static glReadnPixels_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glReadnPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut void, ) -> () {
        let u: usize = glReadnPixels_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLsizei,*mut void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(x, y, width, height, format, type_, bufSize, data, )
      }

      static glReleaseShaderCompiler_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glReleaseShaderCompiler() -> () {
        let u: usize = glReleaseShaderCompiler_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glRenderbufferStorage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glRenderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glRenderbufferStorage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, width, height, )
      }

      static glRenderbufferStorageMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glRenderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glRenderbufferStorageMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, samples, internalformat, width, height, )
      }

      static glResumeTransformFeedback_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glResumeTransformFeedback() -> () {
        let u: usize = glResumeTransformFeedback_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glSampleCoverage_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSampleCoverage(value: GLfloat, invert: GLboolean, ) -> () {
        let u: usize = glSampleCoverage_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLfloat,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(value, invert, )
      }

      static glSampleMaski_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSampleMaski(maskNumber: GLuint, mask: GLbitfield, ) -> () {
        let u: usize = glSampleMaski_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLbitfield,)->() = unsafe { core::mem::transmute(u) };
        _func_p(maskNumber, mask, )
      }

      static glSamplerParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameterIiv(sampler: GLuint, pname: GLenum, param: *const GLint, ) -> () {
        let u: usize = glSamplerParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glSamplerParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameterIuiv(sampler: GLuint, pname: GLenum, param: *const GLuint, ) -> () {
        let u: usize = glSamplerParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glSamplerParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameterf(sampler: GLuint, pname: GLenum, param: GLfloat, ) -> () {
        let u: usize = glSamplerParameterf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glSamplerParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameterfv(sampler: GLuint, pname: GLenum, param: *const GLfloat, ) -> () {
        let u: usize = glSamplerParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glSamplerParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameteri(sampler: GLuint, pname: GLenum, param: GLint, ) -> () {
        let u: usize = glSamplerParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glSamplerParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSamplerParameteriv(sampler: GLuint, pname: GLenum, param: *const GLint, ) -> () {
        let u: usize = glSamplerParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sampler, pname, param, )
      }

      static glScissor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glScissor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(x, y, width, height, )
      }

      static glScissorArrayv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glScissorArrayv(first: GLuint, count: GLsizei, v: *const GLint, ) -> () {
        let u: usize = glScissorArrayv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, v, )
      }

      static glScissorIndexed_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glScissorIndexed(index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glScissorIndexed_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, left, bottom, width, height, )
      }

      static glScissorIndexedv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glScissorIndexedv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glScissorIndexedv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glShaderBinary_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glShaderBinary(count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const void, length: GLsizei, ) -> () {
        let u: usize = glShaderBinary_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsizei,*const GLuint,GLenum,*const void,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(count, shaders, binaryFormat, binary, length, )
      }

      static glShaderSource_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glShaderSource(shader: GLuint, count: GLsizei, string: *const *const GLchar, length: *const GLint, ) -> () {
        let u: usize = glShaderSource_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const *const GLchar,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, count, string, length, )
      }

      static glShaderStorageBlockBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glShaderStorageBlockBinding(program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint, ) -> () {
        let u: usize = glShaderStorageBlockBinding_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, storageBlockIndex, storageBlockBinding, )
      }

      static glSpecializeShader_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glSpecializeShader(shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint, ) -> () {
        let u: usize = glSpecializeShader_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLchar,GLuint,*const GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue, )
      }

      static glStencilFunc_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint, ) -> () {
        let u: usize = glStencilFunc_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(func, ref_, mask, )
      }

      static glStencilFuncSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilFuncSeparate(face: GLenum, func: GLenum, ref_: GLint, mask: GLuint, ) -> () {
        let u: usize = glStencilFuncSeparate_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(face, func, ref_, mask, )
      }

      static glStencilMask_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilMask(mask: GLuint, ) -> () {
        let u: usize = glStencilMask_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(mask, )
      }

      static glStencilMaskSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilMaskSeparate(face: GLenum, mask: GLuint, ) -> () {
        let u: usize = glStencilMaskSeparate_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(face, mask, )
      }

      static glStencilOp_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum, ) -> () {
        let u: usize = glStencilOp_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(fail, zfail, zpass, )
      }

      static glStencilOpSeparate_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glStencilOpSeparate(face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum, ) -> () {
        let u: usize = glStencilOpSeparate_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLenum,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(face, sfail, dpfail, dppass, )
      }

      static glTexBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexBuffer(target: GLenum, internalformat: GLenum, buffer: GLuint, ) -> () {
        let u: usize = glTexBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, buffer, )
      }

      static glTexBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexBufferRange(target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glTexBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, internalformat, buffer, offset, size, )
      }

      static glTexImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexImage1D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLsizei,GLint,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, border, format, type_, pixels, )
      }

      static glTexImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLsizei,GLsizei,GLint,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, height, border, format, type_, pixels, )
      }

      static glTexImage2DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexImage2DMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTexImage2DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, samples, internalformat, width, height, fixedsamplelocations, )
      }

      static glTexImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLsizei,GLsizei,GLsizei,GLint,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, internalformat, width, height, depth, border, format, type_, pixels, )
      }

      static glTexImage3DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexImage3DMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTexImage3DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, samples, internalformat, width, height, depth, fixedsamplelocations, )
      }

      static glTexParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameterIiv(target: GLenum, pname: GLenum, params: *const GLint, ) -> () {
        let u: usize = glTexParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glTexParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameterIuiv(target: GLenum, pname: GLenum, params: *const GLuint, ) -> () {
        let u: usize = glTexParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glTexParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat, ) -> () {
        let u: usize = glTexParameterf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, param, )
      }

      static glTexParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameterfv(target: GLenum, pname: GLenum, params: *const GLfloat, ) -> () {
        let u: usize = glTexParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glTexParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint, ) -> () {
        let u: usize = glTexParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, param, )
      }

      static glTexParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexParameteriv(target: GLenum, pname: GLenum, params: *const GLint, ) -> () {
        let u: usize = glTexParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, pname, params, )
      }

      static glTexStorage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexStorage1D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, ) -> () {
        let u: usize = glTexStorage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, levels, internalformat, width, )
      }

      static glTexStorage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glTexStorage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, levels, internalformat, width, height, )
      }

      static glTexStorage2DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexStorage2DMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTexStorage2DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, samples, internalformat, width, height, fixedsamplelocations, )
      }

      static glTexStorage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, ) -> () {
        let u: usize = glTexStorage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, levels, internalformat, width, height, depth, )
      }

      static glTexStorage3DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexStorage3DMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTexStorage3DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, samples, internalformat, width, height, depth, fixedsamplelocations, )
      }

      static glTexSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexSubImage1D(target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, width, format, type_, pixels, )
      }

      static glTexSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, width, height, format, type_, pixels, )
      }

      static glTexSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTexSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels, )
      }

      static glTextureBarrier_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureBarrier() -> () {
        let u: usize = glTextureBarrier_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn()->() = unsafe { core::mem::transmute(u) };
        _func_p()
      }

      static glTextureBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureBuffer(texture: GLuint, internalformat: GLenum, buffer: GLuint, ) -> () {
        let u: usize = glTextureBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, internalformat, buffer, )
      }

      static glTextureBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureBufferRange(texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glTextureBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, internalformat, buffer, offset, size, )
      }

      static glTextureParameterIiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameterIiv(texture: GLuint, pname: GLenum, params: *const GLint, ) -> () {
        let u: usize = glTextureParameterIiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glTextureParameterIuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameterIuiv(texture: GLuint, pname: GLenum, params: *const GLuint, ) -> () {
        let u: usize = glTextureParameterIuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, params, )
      }

      static glTextureParameterf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameterf(texture: GLuint, pname: GLenum, param: GLfloat, ) -> () {
        let u: usize = glTextureParameterf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, param, )
      }

      static glTextureParameterfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameterfv(texture: GLuint, pname: GLenum, param: *const GLfloat, ) -> () {
        let u: usize = glTextureParameterfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, param, )
      }

      static glTextureParameteri_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameteri(texture: GLuint, pname: GLenum, param: GLint, ) -> () {
        let u: usize = glTextureParameteri_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, param, )
      }

      static glTextureParameteriv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureParameteriv(texture: GLuint, pname: GLenum, param: *const GLint, ) -> () {
        let u: usize = glTextureParameteriv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, pname, param, )
      }

      static glTextureStorage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureStorage1D(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, ) -> () {
        let u: usize = glTextureStorage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, levels, internalformat, width, )
      }

      static glTextureStorage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureStorage2D(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glTextureStorage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, levels, internalformat, width, height, )
      }

      static glTextureStorage2DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureStorage2DMultisample(texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTextureStorage2DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, samples, internalformat, width, height, fixedsamplelocations, )
      }

      static glTextureStorage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureStorage3D(texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, ) -> () {
        let u: usize = glTextureStorage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, levels, internalformat, width, height, depth, )
      }

      static glTextureStorage3DMultisample_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureStorage3DMultisample(texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean, ) -> () {
        let u: usize = glTextureStorage3DMultisample_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, samples, internalformat, width, height, depth, fixedsamplelocations, )
      }

      static glTextureSubImage1D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureSubImage1D(texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTextureSubImage1D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, width, format, type_, pixels, )
      }

      static glTextureSubImage2D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureSubImage2D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTextureSubImage2D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, width, height, format, type_, pixels, )
      }

      static glTextureSubImage3D_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureSubImage3D(texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const void, ) -> () {
        let u: usize = glTextureSubImage3D_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels, )
      }

      static glTextureView_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTextureView(texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint, ) -> () {
        let u: usize = glTextureView_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLuint,GLenum,GLuint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers, )
      }

      static glTransformFeedbackBufferBase_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTransformFeedbackBufferBase(xfb: GLuint, index: GLuint, buffer: GLuint, ) -> () {
        let u: usize = glTransformFeedbackBufferBase_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(xfb, index, buffer, )
      }

      static glTransformFeedbackBufferRange_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTransformFeedbackBufferRange(xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, ) -> () {
        let u: usize = glTransformFeedbackBufferRange_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,GLintptr,GLsizeiptr,)->() = unsafe { core::mem::transmute(u) };
        _func_p(xfb, index, buffer, offset, size, )
      }

      static glTransformFeedbackVaryings_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glTransformFeedbackVaryings(program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum, ) -> () {
        let u: usize = glTransformFeedbackVaryings_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const *const GLchar,GLenum,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, count, varyings, bufferMode, )
      }

      static glUniform1d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1d(location: GLint, x: GLdouble, ) -> () {
        let u: usize = glUniform1d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, x, )
      }

      static glUniform1dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1dv(location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glUniform1dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1f(location: GLint, v0: GLfloat, ) -> () {
        let u: usize = glUniform1f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, )
      }

      static glUniform1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1fv(location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glUniform1fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform1i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1i(location: GLint, v0: GLint, ) -> () {
        let u: usize = glUniform1i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, )
      }

      static glUniform1iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1iv(location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glUniform1iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1ui(location: GLint, v0: GLuint, ) -> () {
        let u: usize = glUniform1ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, )
      }

      static glUniform1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform1uiv(location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glUniform1uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform2d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2d(location: GLint, x: GLdouble, y: GLdouble, ) -> () {
        let u: usize = glUniform2d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, x, y, )
      }

      static glUniform2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2dv(location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glUniform2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2f(location: GLint, v0: GLfloat, v1: GLfloat, ) -> () {
        let u: usize = glUniform2f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, )
      }

      static glUniform2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2fv(location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glUniform2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform2i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2i(location: GLint, v0: GLint, v1: GLint, ) -> () {
        let u: usize = glUniform2i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, )
      }

      static glUniform2iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2iv(location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glUniform2iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2ui(location: GLint, v0: GLuint, v1: GLuint, ) -> () {
        let u: usize = glUniform2ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, )
      }

      static glUniform2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform2uiv(location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glUniform2uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform3d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3d(location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, ) -> () {
        let u: usize = glUniform3d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, x, y, z, )
      }

      static glUniform3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3dv(location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glUniform3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, ) -> () {
        let u: usize = glUniform3f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, )
      }

      static glUniform3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3fv(location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glUniform3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform3i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3i(location: GLint, v0: GLint, v1: GLint, v2: GLint, ) -> () {
        let u: usize = glUniform3i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, )
      }

      static glUniform3iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3iv(location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glUniform3iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, ) -> () {
        let u: usize = glUniform3ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, )
      }

      static glUniform3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform3uiv(location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glUniform3uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform4d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4d(location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble, ) -> () {
        let u: usize = glUniform4d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLdouble,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, x, y, z, w, )
      }

      static glUniform4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4dv(location: GLint, count: GLsizei, value: *const GLdouble, ) -> () {
        let u: usize = glUniform4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat, ) -> () {
        let u: usize = glUniform4f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, v3, )
      }

      static glUniform4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4fv(location: GLint, count: GLsizei, value: *const GLfloat, ) -> () {
        let u: usize = glUniform4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4i(location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint, ) -> () {
        let u: usize = glUniform4i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, v3, )
      }

      static glUniform4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4iv(location: GLint, count: GLsizei, value: *const GLint, ) -> () {
        let u: usize = glUniform4iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniform4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint, ) -> () {
        let u: usize = glUniform4ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLuint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, v0, v1, v2, v3, )
      }

      static glUniform4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniform4uiv(location: GLint, count: GLsizei, value: *const GLuint, ) -> () {
        let u: usize = glUniform4uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, value, )
      }

      static glUniformBlockBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformBlockBinding(program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint, ) -> () {
        let u: usize = glUniformBlockBinding_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, uniformBlockIndex, uniformBlockBinding, )
      }

      static glUniformMatrix2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix2x3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2x3dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix2x3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix2x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix2x3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix2x4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2x4dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix2x4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix2x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix2x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix2x4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3x2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3x2dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix3x2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix3x2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3x4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3x4dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix3x4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix3x4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix3x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix3x4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4x2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4x2dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix4x2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4x2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix4x2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4x3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4x3dv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble, ) -> () {
        let u: usize = glUniformMatrix4x3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformMatrix4x3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformMatrix4x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat, ) -> () {
        let u: usize = glUniformMatrix4x3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLsizei,GLboolean,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(location, count, transpose, value, )
      }

      static glUniformSubroutinesuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUniformSubroutinesuiv(shadertype: GLenum, count: GLsizei, indices: *const GLuint, ) -> () {
        let u: usize = glUniformSubroutinesuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,GLsizei,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(shadertype, count, indices, )
      }

      static glUnmapBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUnmapBuffer(target: GLenum, ) -> GLboolean {
        let u: usize = glUnmapBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLenum,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(target, )
      }

      static glUnmapNamedBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUnmapNamedBuffer(buffer: GLuint, ) -> GLboolean {
        let u: usize = glUnmapNamedBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->GLboolean = unsafe { core::mem::transmute(u) };
        _func_p(buffer, )
      }

      static glUseProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUseProgram(program: GLuint, ) -> () {
        let u: usize = glUseProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, )
      }

      static glUseProgramStages_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glUseProgramStages(pipeline: GLuint, stages: GLbitfield, program: GLuint, ) -> () {
        let u: usize = glUseProgramStages_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLbitfield,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, stages, program, )
      }

      static glValidateProgram_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glValidateProgram(program: GLuint, ) -> () {
        let u: usize = glValidateProgram_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(program, )
      }

      static glValidateProgramPipeline_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glValidateProgramPipeline(pipeline: GLuint, ) -> () {
        let u: usize = glValidateProgramPipeline_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(pipeline, )
      }

      static glVertexArrayAttribBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayAttribBinding(vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint, ) -> () {
        let u: usize = glVertexArrayAttribBinding_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, attribindex, bindingindex, )
      }

      static glVertexArrayAttribFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayAttribFormat(vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexArrayAttribFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, attribindex, size, type_, normalized, relativeoffset, )
      }

      static glVertexArrayAttribIFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayAttribIFormat(vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexArrayAttribIFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLint,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, attribindex, size, type_, relativeoffset, )
      }

      static glVertexArrayAttribLFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayAttribLFormat(vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexArrayAttribLFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLint,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, attribindex, size, type_, relativeoffset, )
      }

      static glVertexArrayBindingDivisor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayBindingDivisor(vaobj: GLuint, bindingindex: GLuint, divisor: GLuint, ) -> () {
        let u: usize = glVertexArrayBindingDivisor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, bindingindex, divisor, )
      }

      static glVertexArrayElementBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayElementBuffer(vaobj: GLuint, buffer: GLuint, ) -> () {
        let u: usize = glVertexArrayElementBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, buffer, )
      }

      static glVertexArrayVertexBuffer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayVertexBuffer(vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei, ) -> () {
        let u: usize = glVertexArrayVertexBuffer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,GLintptr,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, bindingindex, buffer, offset, stride, )
      }

      static glVertexArrayVertexBuffers_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexArrayVertexBuffers(vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei, ) -> () {
        let u: usize = glVertexArrayVertexBuffers_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLsizei,*const GLuint,*const GLintptr,*const GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(vaobj, first, count, buffers, offsets, strides, )
      }

      static glVertexAttrib1d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1d(index: GLuint, x: GLdouble, ) -> () {
        let u: usize = glVertexAttrib1d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttrib1dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttrib1dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib1f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1f(index: GLuint, x: GLfloat, ) -> () {
        let u: usize = glVertexAttrib1f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttrib1fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1fv(index: GLuint, v: *const GLfloat, ) -> () {
        let u: usize = glVertexAttrib1fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib1s_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1s(index: GLuint, x: GLshort, ) -> () {
        let u: usize = glVertexAttrib1s_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttrib1sv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib1sv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttrib1sv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib2d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2d(index: GLuint, x: GLdouble, y: GLdouble, ) -> () {
        let u: usize = glVertexAttrib2d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttrib2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttrib2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib2f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat, ) -> () {
        let u: usize = glVertexAttrib2f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttrib2fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2fv(index: GLuint, v: *const GLfloat, ) -> () {
        let u: usize = glVertexAttrib2fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib2s_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2s(index: GLuint, x: GLshort, y: GLshort, ) -> () {
        let u: usize = glVertexAttrib2s_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLshort,GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttrib2sv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib2sv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttrib2sv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib3d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3d(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, ) -> () {
        let u: usize = glVertexAttrib3d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttrib3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttrib3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib3f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, ) -> () {
        let u: usize = glVertexAttrib3f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttrib3fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3fv(index: GLuint, v: *const GLfloat, ) -> () {
        let u: usize = glVertexAttrib3fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib3s_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3s(index: GLuint, x: GLshort, y: GLshort, z: GLshort, ) -> () {
        let u: usize = glVertexAttrib3s_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLshort,GLshort,GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttrib3sv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib3sv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttrib3sv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Nbv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nbv(index: GLuint, v: *const GLbyte, ) -> () {
        let u: usize = glVertexAttrib4Nbv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLbyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Niv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Niv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttrib4Niv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Nsv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nsv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttrib4Nsv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Nub_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nub(index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte, ) -> () {
        let u: usize = glVertexAttrib4Nub_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLubyte,GLubyte,GLubyte,GLubyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttrib4Nubv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nubv(index: GLuint, v: *const GLubyte, ) -> () {
        let u: usize = glVertexAttrib4Nubv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLubyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Nuiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nuiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttrib4Nuiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4Nusv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4Nusv(index: GLuint, v: *const GLushort, ) -> () {
        let u: usize = glVertexAttrib4Nusv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLushort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4bv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4bv(index: GLuint, v: *const GLbyte, ) -> () {
        let u: usize = glVertexAttrib4bv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLbyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4d(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble, ) -> () {
        let u: usize = glVertexAttrib4d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttrib4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttrib4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4f_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat, ) -> () {
        let u: usize = glVertexAttrib4f_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttrib4fv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4fv(index: GLuint, v: *const GLfloat, ) -> () {
        let u: usize = glVertexAttrib4fv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4iv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttrib4iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4s_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4s(index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort, ) -> () {
        let u: usize = glVertexAttrib4s_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLshort,GLshort,GLshort,GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttrib4sv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4sv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttrib4sv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4ubv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4ubv(index: GLuint, v: *const GLubyte, ) -> () {
        let u: usize = glVertexAttrib4ubv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLubyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4uiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttrib4uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttrib4usv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttrib4usv(index: GLuint, v: *const GLushort, ) -> () {
        let u: usize = glVertexAttrib4usv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLushort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribBinding_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribBinding(attribindex: GLuint, bindingindex: GLuint, ) -> () {
        let u: usize = glVertexAttribBinding_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(attribindex, bindingindex, )
      }

      static glVertexAttribDivisor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribDivisor(index: GLuint, divisor: GLuint, ) -> () {
        let u: usize = glVertexAttribDivisor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, divisor, )
      }

      static glVertexAttribDivisorARB_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribDivisorARB(index: GLuint, divisor: GLuint, ) -> () {
        let u: usize = glVertexAttribDivisorARB_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, divisor, )
      }

      static glVertexAttribFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribFormat(attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexAttribFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(attribindex, size, type_, normalized, relativeoffset, )
      }

      static glVertexAttribI1i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI1i(index: GLuint, x: GLint, ) -> () {
        let u: usize = glVertexAttribI1i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttribI1iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI1iv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttribI1iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI1ui(index: GLuint, x: GLuint, ) -> () {
        let u: usize = glVertexAttribI1ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttribI1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI1uiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttribI1uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI2i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI2i(index: GLuint, x: GLint, y: GLint, ) -> () {
        let u: usize = glVertexAttribI2i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttribI2iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI2iv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttribI2iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI2ui(index: GLuint, x: GLuint, y: GLuint, ) -> () {
        let u: usize = glVertexAttribI2ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttribI2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI2uiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttribI2uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI3i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI3i(index: GLuint, x: GLint, y: GLint, z: GLint, ) -> () {
        let u: usize = glVertexAttribI3i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttribI3iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI3iv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttribI3iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI3ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, ) -> () {
        let u: usize = glVertexAttribI3ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttribI3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI3uiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttribI3uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4bv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4bv(index: GLuint, v: *const GLbyte, ) -> () {
        let u: usize = glVertexAttribI4bv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLbyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4i_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint, ) -> () {
        let u: usize = glVertexAttribI4i_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLint,GLint,GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttribI4iv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4iv(index: GLuint, v: *const GLint, ) -> () {
        let u: usize = glVertexAttribI4iv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4sv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4sv(index: GLuint, v: *const GLshort, ) -> () {
        let u: usize = glVertexAttribI4sv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLshort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4ubv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4ubv(index: GLuint, v: *const GLubyte, ) -> () {
        let u: usize = glVertexAttribI4ubv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLubyte,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint, ) -> () {
        let u: usize = glVertexAttribI4ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,GLuint,GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttribI4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4uiv(index: GLuint, v: *const GLuint, ) -> () {
        let u: usize = glVertexAttribI4uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribI4usv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribI4usv(index: GLuint, v: *const GLushort, ) -> () {
        let u: usize = glVertexAttribI4usv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLushort,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribIFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribIFormat(attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexAttribIFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(attribindex, size, type_, relativeoffset, )
      }

      static glVertexAttribIPointer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribIPointer(index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const void, ) -> () {
        let u: usize = glVertexAttribIPointer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, size, type_, stride, pointer, )
      }

      static glVertexAttribL1d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL1d(index: GLuint, x: GLdouble, ) -> () {
        let u: usize = glVertexAttribL1d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, )
      }

      static glVertexAttribL1dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL1dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttribL1dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribL2d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL2d(index: GLuint, x: GLdouble, y: GLdouble, ) -> () {
        let u: usize = glVertexAttribL2d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, )
      }

      static glVertexAttribL2dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL2dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttribL2dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribL3d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL3d(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, ) -> () {
        let u: usize = glVertexAttribL3d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, )
      }

      static glVertexAttribL3dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL3dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttribL3dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribL4d_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL4d(index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble, ) -> () {
        let u: usize = glVertexAttribL4d_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLdouble,GLdouble,GLdouble,GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, z, w, )
      }

      static glVertexAttribL4dv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribL4dv(index: GLuint, v: *const GLdouble, ) -> () {
        let u: usize = glVertexAttribL4dv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLdouble,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glVertexAttribLFormat_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribLFormat(attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint, ) -> () {
        let u: usize = glVertexAttribLFormat_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(attribindex, size, type_, relativeoffset, )
      }

      static glVertexAttribLPointer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribLPointer(index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const void, ) -> () {
        let u: usize = glVertexAttribLPointer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, size, type_, stride, pointer, )
      }

      static glVertexAttribP1ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP1ui(index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint, ) -> () {
        let u: usize = glVertexAttribP1ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP1uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP1uiv(index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint, ) -> () {
        let u: usize = glVertexAttribP1uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP2ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP2ui(index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint, ) -> () {
        let u: usize = glVertexAttribP2ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP2uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP2uiv(index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint, ) -> () {
        let u: usize = glVertexAttribP2uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP3ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP3ui(index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint, ) -> () {
        let u: usize = glVertexAttribP3ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP3uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP3uiv(index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint, ) -> () {
        let u: usize = glVertexAttribP3uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP4ui_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP4ui(index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint, ) -> () {
        let u: usize = glVertexAttribP4ui_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribP4uiv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribP4uiv(index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint, ) -> () {
        let u: usize = glVertexAttribP4uiv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLenum,GLboolean,*const GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, type_, normalized, value, )
      }

      static glVertexAttribPointer_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexAttribPointer(index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const void, ) -> () {
        let u: usize = glVertexAttribPointer_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLint,GLenum,GLboolean,GLsizei,*const void,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, size, type_, normalized, stride, pointer, )
      }

      static glVertexBindingDivisor_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glVertexBindingDivisor(bindingindex: GLuint, divisor: GLuint, ) -> () {
        let u: usize = glVertexBindingDivisor_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLuint,)->() = unsafe { core::mem::transmute(u) };
        _func_p(bindingindex, divisor, )
      }

      static glViewport_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glViewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei, ) -> () {
        let u: usize = glViewport_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLint,GLint,GLsizei,GLsizei,)->() = unsafe { core::mem::transmute(u) };
        _func_p(x, y, width, height, )
      }

      static glViewportArrayv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glViewportArrayv(first: GLuint, count: GLsizei, v: *const GLfloat, ) -> () {
        let u: usize = glViewportArrayv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLsizei,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(first, count, v, )
      }

      static glViewportIndexedf_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glViewportIndexedf(index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat, ) -> () {
        let u: usize = glViewportIndexedf_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,GLfloat,GLfloat,GLfloat,GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, x, y, w, h, )
      }

      static glViewportIndexedfv_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glViewportIndexedfv(index: GLuint, v: *const GLfloat, ) -> () {
        let u: usize = glViewportIndexedfv_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLuint,*const GLfloat,)->() = unsafe { core::mem::transmute(u) };
        _func_p(index, v, )
      }

      static glWaitSync_p: core::sync::atomic::AtomicUsize = core::sync::atomic::AtomicUsize::new(0);
      #[inline]
      pub unsafe fn glWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64, ) -> () {
        let u: usize = glWaitSync_p.load(core::sync::atomic::Ordering::Acquire);
        assert!(u != 0);
        let _func_p: unsafe extern "system" fn(GLsync,GLbitfield,GLuint64,)->() = unsafe { core::mem::transmute(u) };
        _func_p(sync, flags, timeout, )
      }

    /// Loads all GL function pointers.
    /// 
    /// In general, one cannot statically or dynamically link to GL functions.
    /// The functions are often specific to a particular GL context, and so they
    /// can only be loaded at runtime, once a GL context has been created and
    /// made current.
    /// 
    /// This module stores one `static` address value per GL function. When you
    /// call a GL function from this module, it loads the address out of the
    /// static, and if the address is non-null it calls that address (if the
    /// address is null it will panic).
    /// 
    /// Calling `load_gl_functions` allows you to initialize all of the static
    /// address values. This should generally be done just once, after your GL
    /// context is created and made current.
    /// 
    /// ## Safety
    /// * The `load_fn` you provide is passed the start of a zero-terminated
    ///   string naming each GL command. It must use this pointer to load that
    ///   GL command's pointer using the appropriate platform function, then
    ///   return that value.
    /// * When the platform loader fails to load a GL function it will generally
    ///   return the null address, though error addresses of 1, 2, 3, and -1
    ///   have also been seen on some systems. All of these addresses are
    ///   treated as failed loads, and will store null into the `static`.
    /// 
    /// ## Failure
    /// * Returns `Ok` when all functions load successfully. Otherwise you will
    ///   get an `Err` with a list of all functions that failed to load.
    /// * The loading process does not "early return". It will always attempt
    ///   to load all functions, only returning the list of errors at the end.
    pub unsafe fn load_gl_functions(load_fn: &dyn Fn(*const u8) -> *const void) -> Result<(), Vec<&'static str>> {
      let command_info = &[("glActiveShaderProgram\0", &glActiveShaderProgram_p),
("glActiveTexture\0", &glActiveTexture_p),
("glAttachShader\0", &glAttachShader_p),
("glBeginConditionalRender\0", &glBeginConditionalRender_p),
("glBeginQuery\0", &glBeginQuery_p),
("glBeginQueryIndexed\0", &glBeginQueryIndexed_p),
("glBeginTransformFeedback\0", &glBeginTransformFeedback_p),
("glBindAttribLocation\0", &glBindAttribLocation_p),
("glBindBuffer\0", &glBindBuffer_p),
("glBindBufferBase\0", &glBindBufferBase_p),
("glBindBufferRange\0", &glBindBufferRange_p),
("glBindBuffersBase\0", &glBindBuffersBase_p),
("glBindBuffersRange\0", &glBindBuffersRange_p),
("glBindFragDataLocation\0", &glBindFragDataLocation_p),
("glBindFragDataLocationIndexed\0", &glBindFragDataLocationIndexed_p),
("glBindFramebuffer\0", &glBindFramebuffer_p),
("glBindImageTexture\0", &glBindImageTexture_p),
("glBindImageTextures\0", &glBindImageTextures_p),
("glBindProgramPipeline\0", &glBindProgramPipeline_p),
("glBindRenderbuffer\0", &glBindRenderbuffer_p),
("glBindSampler\0", &glBindSampler_p),
("glBindSamplers\0", &glBindSamplers_p),
("glBindTexture\0", &glBindTexture_p),
("glBindTextureUnit\0", &glBindTextureUnit_p),
("glBindTextures\0", &glBindTextures_p),
("glBindTransformFeedback\0", &glBindTransformFeedback_p),
("glBindVertexArray\0", &glBindVertexArray_p),
("glBindVertexBuffer\0", &glBindVertexBuffer_p),
("glBindVertexBuffers\0", &glBindVertexBuffers_p),
("glBlendColor\0", &glBlendColor_p),
("glBlendEquation\0", &glBlendEquation_p),
("glBlendEquationSeparate\0", &glBlendEquationSeparate_p),
("glBlendEquationSeparatei\0", &glBlendEquationSeparatei_p),
("glBlendEquationi\0", &glBlendEquationi_p),
("glBlendFunc\0", &glBlendFunc_p),
("glBlendFuncSeparate\0", &glBlendFuncSeparate_p),
("glBlendFuncSeparatei\0", &glBlendFuncSeparatei_p),
("glBlendFunci\0", &glBlendFunci_p),
("glBlitFramebuffer\0", &glBlitFramebuffer_p),
("glBlitNamedFramebuffer\0", &glBlitNamedFramebuffer_p),
("glBufferData\0", &glBufferData_p),
("glBufferStorage\0", &glBufferStorage_p),
("glBufferStorageEXT\0", &glBufferStorageEXT_p),
("glBufferSubData\0", &glBufferSubData_p),
("glCheckFramebufferStatus\0", &glCheckFramebufferStatus_p),
("glCheckNamedFramebufferStatus\0", &glCheckNamedFramebufferStatus_p),
("glClampColor\0", &glClampColor_p),
("glClear\0", &glClear_p),
("glClearBufferData\0", &glClearBufferData_p),
("glClearBufferSubData\0", &glClearBufferSubData_p),
("glClearBufferfi\0", &glClearBufferfi_p),
("glClearBufferfv\0", &glClearBufferfv_p),
("glClearBufferiv\0", &glClearBufferiv_p),
("glClearBufferuiv\0", &glClearBufferuiv_p),
("glClearColor\0", &glClearColor_p),
("glClearDepth\0", &glClearDepth_p),
("glClearDepthf\0", &glClearDepthf_p),
("glClearNamedBufferData\0", &glClearNamedBufferData_p),
("glClearNamedBufferSubData\0", &glClearNamedBufferSubData_p),
("glClearNamedFramebufferfi\0", &glClearNamedFramebufferfi_p),
("glClearNamedFramebufferfv\0", &glClearNamedFramebufferfv_p),
("glClearNamedFramebufferiv\0", &glClearNamedFramebufferiv_p),
("glClearNamedFramebufferuiv\0", &glClearNamedFramebufferuiv_p),
("glClearStencil\0", &glClearStencil_p),
("glClearTexImage\0", &glClearTexImage_p),
("glClearTexSubImage\0", &glClearTexSubImage_p),
("glClientWaitSync\0", &glClientWaitSync_p),
("glClipControl\0", &glClipControl_p),
("glColorMask\0", &glColorMask_p),
("glColorMaskIndexedEXT\0", &glColorMaskIndexedEXT_p),
("glColorMaski\0", &glColorMaski_p),
("glCompileShader\0", &glCompileShader_p),
("glCompressedTexImage1D\0", &glCompressedTexImage1D_p),
("glCompressedTexImage2D\0", &glCompressedTexImage2D_p),
("glCompressedTexImage3D\0", &glCompressedTexImage3D_p),
("glCompressedTexSubImage1D\0", &glCompressedTexSubImage1D_p),
("glCompressedTexSubImage2D\0", &glCompressedTexSubImage2D_p),
("glCompressedTexSubImage3D\0", &glCompressedTexSubImage3D_p),
("glCompressedTextureSubImage1D\0", &glCompressedTextureSubImage1D_p),
("glCompressedTextureSubImage2D\0", &glCompressedTextureSubImage2D_p),
("glCompressedTextureSubImage3D\0", &glCompressedTextureSubImage3D_p),
("glCopyBufferSubData\0", &glCopyBufferSubData_p),
("glCopyBufferSubDataNV\0", &glCopyBufferSubDataNV_p),
("glCopyImageSubData\0", &glCopyImageSubData_p),
("glCopyNamedBufferSubData\0", &glCopyNamedBufferSubData_p),
("glCopyTexImage1D\0", &glCopyTexImage1D_p),
("glCopyTexImage2D\0", &glCopyTexImage2D_p),
("glCopyTexSubImage1D\0", &glCopyTexSubImage1D_p),
("glCopyTexSubImage2D\0", &glCopyTexSubImage2D_p),
("glCopyTexSubImage3D\0", &glCopyTexSubImage3D_p),
("glCopyTextureSubImage1D\0", &glCopyTextureSubImage1D_p),
("glCopyTextureSubImage2D\0", &glCopyTextureSubImage2D_p),
("glCopyTextureSubImage3D\0", &glCopyTextureSubImage3D_p),
("glCreateBuffers\0", &glCreateBuffers_p),
("glCreateFramebuffers\0", &glCreateFramebuffers_p),
("glCreateProgram\0", &glCreateProgram_p),
("glCreateProgramPipelines\0", &glCreateProgramPipelines_p),
("glCreateQueries\0", &glCreateQueries_p),
("glCreateRenderbuffers\0", &glCreateRenderbuffers_p),
("glCreateSamplers\0", &glCreateSamplers_p),
("glCreateShader\0", &glCreateShader_p),
("glCreateShaderProgramv\0", &glCreateShaderProgramv_p),
("glCreateTextures\0", &glCreateTextures_p),
("glCreateTransformFeedbacks\0", &glCreateTransformFeedbacks_p),
("glCreateVertexArrays\0", &glCreateVertexArrays_p),
("glCullFace\0", &glCullFace_p),
("glDebugMessageCallback\0", &glDebugMessageCallback_p),
("glDebugMessageCallbackARB\0", &glDebugMessageCallbackARB_p),
("glDebugMessageCallbackKHR\0", &glDebugMessageCallbackKHR_p),
("glDebugMessageControl\0", &glDebugMessageControl_p),
("glDebugMessageControlARB\0", &glDebugMessageControlARB_p),
("glDebugMessageControlKHR\0", &glDebugMessageControlKHR_p),
("glDebugMessageInsert\0", &glDebugMessageInsert_p),
("glDebugMessageInsertARB\0", &glDebugMessageInsertARB_p),
("glDebugMessageInsertKHR\0", &glDebugMessageInsertKHR_p),
("glDeleteBuffers\0", &glDeleteBuffers_p),
("glDeleteFramebuffers\0", &glDeleteFramebuffers_p),
("glDeleteProgram\0", &glDeleteProgram_p),
("glDeleteProgramPipelines\0", &glDeleteProgramPipelines_p),
("glDeleteQueries\0", &glDeleteQueries_p),
("glDeleteRenderbuffers\0", &glDeleteRenderbuffers_p),
("glDeleteSamplers\0", &glDeleteSamplers_p),
("glDeleteShader\0", &glDeleteShader_p),
("glDeleteSync\0", &glDeleteSync_p),
("glDeleteTextures\0", &glDeleteTextures_p),
("glDeleteTransformFeedbacks\0", &glDeleteTransformFeedbacks_p),
("glDeleteVertexArrays\0", &glDeleteVertexArrays_p),
("glDepthFunc\0", &glDepthFunc_p),
("glDepthMask\0", &glDepthMask_p),
("glDepthRange\0", &glDepthRange_p),
("glDepthRangeArrayv\0", &glDepthRangeArrayv_p),
("glDepthRangeIndexed\0", &glDepthRangeIndexed_p),
("glDepthRangef\0", &glDepthRangef_p),
("glDetachShader\0", &glDetachShader_p),
("glDisable\0", &glDisable_p),
("glDisableIndexedEXT\0", &glDisableIndexedEXT_p),
("glDisableVertexArrayAttrib\0", &glDisableVertexArrayAttrib_p),
("glDisableVertexAttribArray\0", &glDisableVertexAttribArray_p),
("glDisablei\0", &glDisablei_p),
("glDispatchCompute\0", &glDispatchCompute_p),
("glDispatchComputeIndirect\0", &glDispatchComputeIndirect_p),
("glDrawArrays\0", &glDrawArrays_p),
("glDrawArraysIndirect\0", &glDrawArraysIndirect_p),
("glDrawArraysInstanced\0", &glDrawArraysInstanced_p),
("glDrawArraysInstancedARB\0", &glDrawArraysInstancedARB_p),
("glDrawArraysInstancedBaseInstance\0", &glDrawArraysInstancedBaseInstance_p),
("glDrawBuffer\0", &glDrawBuffer_p),
("glDrawBuffers\0", &glDrawBuffers_p),
("glDrawElements\0", &glDrawElements_p),
("glDrawElementsBaseVertex\0", &glDrawElementsBaseVertex_p),
("glDrawElementsIndirect\0", &glDrawElementsIndirect_p),
("glDrawElementsInstanced\0", &glDrawElementsInstanced_p),
("glDrawElementsInstancedARB\0", &glDrawElementsInstancedARB_p),
("glDrawElementsInstancedBaseInstance\0", &glDrawElementsInstancedBaseInstance_p),
("glDrawElementsInstancedBaseVertex\0", &glDrawElementsInstancedBaseVertex_p),
("glDrawElementsInstancedBaseVertexBaseInstance\0", &glDrawElementsInstancedBaseVertexBaseInstance_p),
("glDrawRangeElements\0", &glDrawRangeElements_p),
("glDrawRangeElementsBaseVertex\0", &glDrawRangeElementsBaseVertex_p),
("glDrawTransformFeedback\0", &glDrawTransformFeedback_p),
("glDrawTransformFeedbackInstanced\0", &glDrawTransformFeedbackInstanced_p),
("glDrawTransformFeedbackStream\0", &glDrawTransformFeedbackStream_p),
("glDrawTransformFeedbackStreamInstanced\0", &glDrawTransformFeedbackStreamInstanced_p),
("glEnable\0", &glEnable_p),
("glEnableIndexedEXT\0", &glEnableIndexedEXT_p),
("glEnableVertexArrayAttrib\0", &glEnableVertexArrayAttrib_p),
("glEnableVertexAttribArray\0", &glEnableVertexAttribArray_p),
("glEnablei\0", &glEnablei_p),
("glEndConditionalRender\0", &glEndConditionalRender_p),
("glEndQuery\0", &glEndQuery_p),
("glEndQueryIndexed\0", &glEndQueryIndexed_p),
("glEndTransformFeedback\0", &glEndTransformFeedback_p),
("glFenceSync\0", &glFenceSync_p),
("glFinish\0", &glFinish_p),
("glFlush\0", &glFlush_p),
("glFlushMappedBufferRange\0", &glFlushMappedBufferRange_p),
("glFlushMappedNamedBufferRange\0", &glFlushMappedNamedBufferRange_p),
("glFramebufferParameteri\0", &glFramebufferParameteri_p),
("glFramebufferRenderbuffer\0", &glFramebufferRenderbuffer_p),
("glFramebufferTexture\0", &glFramebufferTexture_p),
("glFramebufferTexture1D\0", &glFramebufferTexture1D_p),
("glFramebufferTexture2D\0", &glFramebufferTexture2D_p),
("glFramebufferTexture3D\0", &glFramebufferTexture3D_p),
("glFramebufferTextureLayer\0", &glFramebufferTextureLayer_p),
("glFrontFace\0", &glFrontFace_p),
("glGenBuffers\0", &glGenBuffers_p),
("glGenFramebuffers\0", &glGenFramebuffers_p),
("glGenProgramPipelines\0", &glGenProgramPipelines_p),
("glGenQueries\0", &glGenQueries_p),
("glGenRenderbuffers\0", &glGenRenderbuffers_p),
("glGenSamplers\0", &glGenSamplers_p),
("glGenTextures\0", &glGenTextures_p),
("glGenTransformFeedbacks\0", &glGenTransformFeedbacks_p),
("glGenVertexArrays\0", &glGenVertexArrays_p),
("glGenerateMipmap\0", &glGenerateMipmap_p),
("glGenerateTextureMipmap\0", &glGenerateTextureMipmap_p),
("glGetActiveAtomicCounterBufferiv\0", &glGetActiveAtomicCounterBufferiv_p),
("glGetActiveAttrib\0", &glGetActiveAttrib_p),
("glGetActiveSubroutineName\0", &glGetActiveSubroutineName_p),
("glGetActiveSubroutineUniformName\0", &glGetActiveSubroutineUniformName_p),
("glGetActiveSubroutineUniformiv\0", &glGetActiveSubroutineUniformiv_p),
("glGetActiveUniform\0", &glGetActiveUniform_p),
("glGetActiveUniformBlockName\0", &glGetActiveUniformBlockName_p),
("glGetActiveUniformBlockiv\0", &glGetActiveUniformBlockiv_p),
("glGetActiveUniformName\0", &glGetActiveUniformName_p),
("glGetActiveUniformsiv\0", &glGetActiveUniformsiv_p),
("glGetAttachedShaders\0", &glGetAttachedShaders_p),
("glGetAttribLocation\0", &glGetAttribLocation_p),
("glGetBooleanIndexedvEXT\0", &glGetBooleanIndexedvEXT_p),
("glGetBooleani_v\0", &glGetBooleani_v_p),
("glGetBooleanv\0", &glGetBooleanv_p),
("glGetBufferParameteri64v\0", &glGetBufferParameteri64v_p),
("glGetBufferParameteriv\0", &glGetBufferParameteriv_p),
("glGetBufferPointerv\0", &glGetBufferPointerv_p),
("glGetBufferSubData\0", &glGetBufferSubData_p),
("glGetCompressedTexImage\0", &glGetCompressedTexImage_p),
("glGetCompressedTextureImage\0", &glGetCompressedTextureImage_p),
("glGetCompressedTextureSubImage\0", &glGetCompressedTextureSubImage_p),
("glGetDebugMessageLog\0", &glGetDebugMessageLog_p),
("glGetDebugMessageLogARB\0", &glGetDebugMessageLogARB_p),
("glGetDebugMessageLogKHR\0", &glGetDebugMessageLogKHR_p),
("glGetDoublei_v\0", &glGetDoublei_v_p),
("glGetDoublev\0", &glGetDoublev_p),
("glGetError\0", &glGetError_p),
("glGetFloati_v\0", &glGetFloati_v_p),
("glGetFloatv\0", &glGetFloatv_p),
("glGetFragDataIndex\0", &glGetFragDataIndex_p),
("glGetFragDataLocation\0", &glGetFragDataLocation_p),
("glGetFramebufferAttachmentParameteriv\0", &glGetFramebufferAttachmentParameteriv_p),
("glGetFramebufferParameteriv\0", &glGetFramebufferParameteriv_p),
("glGetGraphicsResetStatus\0", &glGetGraphicsResetStatus_p),
("glGetInteger64i_v\0", &glGetInteger64i_v_p),
("glGetInteger64v\0", &glGetInteger64v_p),
("glGetIntegerIndexedvEXT\0", &glGetIntegerIndexedvEXT_p),
("glGetIntegeri_v\0", &glGetIntegeri_v_p),
("glGetIntegerv\0", &glGetIntegerv_p),
("glGetInternalformati64v\0", &glGetInternalformati64v_p),
("glGetInternalformativ\0", &glGetInternalformativ_p),
("glGetMultisamplefv\0", &glGetMultisamplefv_p),
("glGetNamedBufferParameteri64v\0", &glGetNamedBufferParameteri64v_p),
("glGetNamedBufferParameteriv\0", &glGetNamedBufferParameteriv_p),
("glGetNamedBufferPointerv\0", &glGetNamedBufferPointerv_p),
("glGetNamedBufferSubData\0", &glGetNamedBufferSubData_p),
("glGetNamedFramebufferAttachmentParameteriv\0", &glGetNamedFramebufferAttachmentParameteriv_p),
("glGetNamedFramebufferParameteriv\0", &glGetNamedFramebufferParameteriv_p),
("glGetNamedRenderbufferParameteriv\0", &glGetNamedRenderbufferParameteriv_p),
("glGetObjectLabel\0", &glGetObjectLabel_p),
("glGetObjectLabelKHR\0", &glGetObjectLabelKHR_p),
("glGetObjectPtrLabel\0", &glGetObjectPtrLabel_p),
("glGetObjectPtrLabelKHR\0", &glGetObjectPtrLabelKHR_p),
("glGetPointerv\0", &glGetPointerv_p),
("glGetPointervKHR\0", &glGetPointervKHR_p),
("glGetProgramBinary\0", &glGetProgramBinary_p),
("glGetProgramInfoLog\0", &glGetProgramInfoLog_p),
("glGetProgramInterfaceiv\0", &glGetProgramInterfaceiv_p),
("glGetProgramPipelineInfoLog\0", &glGetProgramPipelineInfoLog_p),
("glGetProgramPipelineiv\0", &glGetProgramPipelineiv_p),
("glGetProgramResourceIndex\0", &glGetProgramResourceIndex_p),
("glGetProgramResourceLocation\0", &glGetProgramResourceLocation_p),
("glGetProgramResourceLocationIndex\0", &glGetProgramResourceLocationIndex_p),
("glGetProgramResourceName\0", &glGetProgramResourceName_p),
("glGetProgramResourceiv\0", &glGetProgramResourceiv_p),
("glGetProgramStageiv\0", &glGetProgramStageiv_p),
("glGetProgramiv\0", &glGetProgramiv_p),
("glGetQueryBufferObjecti64v\0", &glGetQueryBufferObjecti64v_p),
("glGetQueryBufferObjectiv\0", &glGetQueryBufferObjectiv_p),
("glGetQueryBufferObjectui64v\0", &glGetQueryBufferObjectui64v_p),
("glGetQueryBufferObjectuiv\0", &glGetQueryBufferObjectuiv_p),
("glGetQueryIndexediv\0", &glGetQueryIndexediv_p),
("glGetQueryObjecti64v\0", &glGetQueryObjecti64v_p),
("glGetQueryObjectiv\0", &glGetQueryObjectiv_p),
("glGetQueryObjectui64v\0", &glGetQueryObjectui64v_p),
("glGetQueryObjectuiv\0", &glGetQueryObjectuiv_p),
("glGetQueryiv\0", &glGetQueryiv_p),
("glGetRenderbufferParameteriv\0", &glGetRenderbufferParameteriv_p),
("glGetSamplerParameterIiv\0", &glGetSamplerParameterIiv_p),
("glGetSamplerParameterIuiv\0", &glGetSamplerParameterIuiv_p),
("glGetSamplerParameterfv\0", &glGetSamplerParameterfv_p),
("glGetSamplerParameteriv\0", &glGetSamplerParameteriv_p),
("glGetShaderInfoLog\0", &glGetShaderInfoLog_p),
("glGetShaderPrecisionFormat\0", &glGetShaderPrecisionFormat_p),
("glGetShaderSource\0", &glGetShaderSource_p),
("glGetShaderiv\0", &glGetShaderiv_p),
("glGetString\0", &glGetString_p),
("glGetStringi\0", &glGetStringi_p),
("glGetSubroutineIndex\0", &glGetSubroutineIndex_p),
("glGetSubroutineUniformLocation\0", &glGetSubroutineUniformLocation_p),
("glGetSynciv\0", &glGetSynciv_p),
("glGetTexImage\0", &glGetTexImage_p),
("glGetTexLevelParameterfv\0", &glGetTexLevelParameterfv_p),
("glGetTexLevelParameteriv\0", &glGetTexLevelParameteriv_p),
("glGetTexParameterIiv\0", &glGetTexParameterIiv_p),
("glGetTexParameterIuiv\0", &glGetTexParameterIuiv_p),
("glGetTexParameterfv\0", &glGetTexParameterfv_p),
("glGetTexParameteriv\0", &glGetTexParameteriv_p),
("glGetTextureImage\0", &glGetTextureImage_p),
("glGetTextureLevelParameterfv\0", &glGetTextureLevelParameterfv_p),
("glGetTextureLevelParameteriv\0", &glGetTextureLevelParameteriv_p),
("glGetTextureParameterIiv\0", &glGetTextureParameterIiv_p),
("glGetTextureParameterIuiv\0", &glGetTextureParameterIuiv_p),
("glGetTextureParameterfv\0", &glGetTextureParameterfv_p),
("glGetTextureParameteriv\0", &glGetTextureParameteriv_p),
("glGetTextureSubImage\0", &glGetTextureSubImage_p),
("glGetTransformFeedbackVarying\0", &glGetTransformFeedbackVarying_p),
("glGetTransformFeedbacki64_v\0", &glGetTransformFeedbacki64_v_p),
("glGetTransformFeedbacki_v\0", &glGetTransformFeedbacki_v_p),
("glGetTransformFeedbackiv\0", &glGetTransformFeedbackiv_p),
("glGetUniformBlockIndex\0", &glGetUniformBlockIndex_p),
("glGetUniformIndices\0", &glGetUniformIndices_p),
("glGetUniformLocation\0", &glGetUniformLocation_p),
("glGetUniformSubroutineuiv\0", &glGetUniformSubroutineuiv_p),
("glGetUniformdv\0", &glGetUniformdv_p),
("glGetUniformfv\0", &glGetUniformfv_p),
("glGetUniformiv\0", &glGetUniformiv_p),
("glGetUniformuiv\0", &glGetUniformuiv_p),
("glGetVertexArrayIndexed64iv\0", &glGetVertexArrayIndexed64iv_p),
("glGetVertexArrayIndexediv\0", &glGetVertexArrayIndexediv_p),
("glGetVertexArrayiv\0", &glGetVertexArrayiv_p),
("glGetVertexAttribIiv\0", &glGetVertexAttribIiv_p),
("glGetVertexAttribIuiv\0", &glGetVertexAttribIuiv_p),
("glGetVertexAttribLdv\0", &glGetVertexAttribLdv_p),
("glGetVertexAttribPointerv\0", &glGetVertexAttribPointerv_p),
("glGetVertexAttribdv\0", &glGetVertexAttribdv_p),
("glGetVertexAttribfv\0", &glGetVertexAttribfv_p),
("glGetVertexAttribiv\0", &glGetVertexAttribiv_p),
("glGetnCompressedTexImage\0", &glGetnCompressedTexImage_p),
("glGetnTexImage\0", &glGetnTexImage_p),
("glGetnUniformdv\0", &glGetnUniformdv_p),
("glGetnUniformfv\0", &glGetnUniformfv_p),
("glGetnUniformiv\0", &glGetnUniformiv_p),
("glGetnUniformuiv\0", &glGetnUniformuiv_p),
("glHint\0", &glHint_p),
("glInvalidateBufferData\0", &glInvalidateBufferData_p),
("glInvalidateBufferSubData\0", &glInvalidateBufferSubData_p),
("glInvalidateFramebuffer\0", &glInvalidateFramebuffer_p),
("glInvalidateNamedFramebufferData\0", &glInvalidateNamedFramebufferData_p),
("glInvalidateNamedFramebufferSubData\0", &glInvalidateNamedFramebufferSubData_p),
("glInvalidateSubFramebuffer\0", &glInvalidateSubFramebuffer_p),
("glInvalidateTexImage\0", &glInvalidateTexImage_p),
("glInvalidateTexSubImage\0", &glInvalidateTexSubImage_p),
("glIsBuffer\0", &glIsBuffer_p),
("glIsEnabled\0", &glIsEnabled_p),
("glIsEnabledIndexedEXT\0", &glIsEnabledIndexedEXT_p),
("glIsEnabledi\0", &glIsEnabledi_p),
("glIsFramebuffer\0", &glIsFramebuffer_p),
("glIsProgram\0", &glIsProgram_p),
("glIsProgramPipeline\0", &glIsProgramPipeline_p),
("glIsQuery\0", &glIsQuery_p),
("glIsRenderbuffer\0", &glIsRenderbuffer_p),
("glIsSampler\0", &glIsSampler_p),
("glIsShader\0", &glIsShader_p),
("glIsSync\0", &glIsSync_p),
("glIsTexture\0", &glIsTexture_p),
("glIsTransformFeedback\0", &glIsTransformFeedback_p),
("glIsVertexArray\0", &glIsVertexArray_p),
("glLineWidth\0", &glLineWidth_p),
("glLinkProgram\0", &glLinkProgram_p),
("glLogicOp\0", &glLogicOp_p),
("glMapBuffer\0", &glMapBuffer_p),
("glMapBufferRange\0", &glMapBufferRange_p),
("glMapNamedBuffer\0", &glMapNamedBuffer_p),
("glMapNamedBufferRange\0", &glMapNamedBufferRange_p),
("glMaxShaderCompilerThreadsARB\0", &glMaxShaderCompilerThreadsARB_p),
("glMaxShaderCompilerThreadsKHR\0", &glMaxShaderCompilerThreadsKHR_p),
("glMemoryBarrier\0", &glMemoryBarrier_p),
("glMemoryBarrierByRegion\0", &glMemoryBarrierByRegion_p),
("glMinSampleShading\0", &glMinSampleShading_p),
("glMultiDrawArrays\0", &glMultiDrawArrays_p),
("glMultiDrawArraysIndirect\0", &glMultiDrawArraysIndirect_p),
("glMultiDrawArraysIndirectCount\0", &glMultiDrawArraysIndirectCount_p),
("glMultiDrawElements\0", &glMultiDrawElements_p),
("glMultiDrawElementsBaseVertex\0", &glMultiDrawElementsBaseVertex_p),
("glMultiDrawElementsIndirect\0", &glMultiDrawElementsIndirect_p),
("glMultiDrawElementsIndirectCount\0", &glMultiDrawElementsIndirectCount_p),
("glNamedBufferData\0", &glNamedBufferData_p),
("glNamedBufferStorage\0", &glNamedBufferStorage_p),
("glNamedBufferSubData\0", &glNamedBufferSubData_p),
("glNamedFramebufferDrawBuffer\0", &glNamedFramebufferDrawBuffer_p),
("glNamedFramebufferDrawBuffers\0", &glNamedFramebufferDrawBuffers_p),
("glNamedFramebufferParameteri\0", &glNamedFramebufferParameteri_p),
("glNamedFramebufferReadBuffer\0", &glNamedFramebufferReadBuffer_p),
("glNamedFramebufferRenderbuffer\0", &glNamedFramebufferRenderbuffer_p),
("glNamedFramebufferTexture\0", &glNamedFramebufferTexture_p),
("glNamedFramebufferTextureLayer\0", &glNamedFramebufferTextureLayer_p),
("glNamedRenderbufferStorage\0", &glNamedRenderbufferStorage_p),
("glNamedRenderbufferStorageMultisample\0", &glNamedRenderbufferStorageMultisample_p),
("glObjectLabel\0", &glObjectLabel_p),
("glObjectLabelKHR\0", &glObjectLabelKHR_p),
("glObjectPtrLabel\0", &glObjectPtrLabel_p),
("glObjectPtrLabelKHR\0", &glObjectPtrLabelKHR_p),
("glPatchParameterfv\0", &glPatchParameterfv_p),
("glPatchParameteri\0", &glPatchParameteri_p),
("glPauseTransformFeedback\0", &glPauseTransformFeedback_p),
("glPixelStoref\0", &glPixelStoref_p),
("glPixelStorei\0", &glPixelStorei_p),
("glPointParameterf\0", &glPointParameterf_p),
("glPointParameterfv\0", &glPointParameterfv_p),
("glPointParameteri\0", &glPointParameteri_p),
("glPointParameteriv\0", &glPointParameteriv_p),
("glPointSize\0", &glPointSize_p),
("glPolygonMode\0", &glPolygonMode_p),
("glPolygonOffset\0", &glPolygonOffset_p),
("glPolygonOffsetClamp\0", &glPolygonOffsetClamp_p),
("glPopDebugGroup\0", &glPopDebugGroup_p),
("glPopDebugGroupKHR\0", &glPopDebugGroupKHR_p),
("glPrimitiveRestartIndex\0", &glPrimitiveRestartIndex_p),
("glProgramBinary\0", &glProgramBinary_p),
("glProgramParameteri\0", &glProgramParameteri_p),
("glProgramUniform1d\0", &glProgramUniform1d_p),
("glProgramUniform1dv\0", &glProgramUniform1dv_p),
("glProgramUniform1f\0", &glProgramUniform1f_p),
("glProgramUniform1fv\0", &glProgramUniform1fv_p),
("glProgramUniform1i\0", &glProgramUniform1i_p),
("glProgramUniform1iv\0", &glProgramUniform1iv_p),
("glProgramUniform1ui\0", &glProgramUniform1ui_p),
("glProgramUniform1uiv\0", &glProgramUniform1uiv_p),
("glProgramUniform2d\0", &glProgramUniform2d_p),
("glProgramUniform2dv\0", &glProgramUniform2dv_p),
("glProgramUniform2f\0", &glProgramUniform2f_p),
("glProgramUniform2fv\0", &glProgramUniform2fv_p),
("glProgramUniform2i\0", &glProgramUniform2i_p),
("glProgramUniform2iv\0", &glProgramUniform2iv_p),
("glProgramUniform2ui\0", &glProgramUniform2ui_p),
("glProgramUniform2uiv\0", &glProgramUniform2uiv_p),
("glProgramUniform3d\0", &glProgramUniform3d_p),
("glProgramUniform3dv\0", &glProgramUniform3dv_p),
("glProgramUniform3f\0", &glProgramUniform3f_p),
("glProgramUniform3fv\0", &glProgramUniform3fv_p),
("glProgramUniform3i\0", &glProgramUniform3i_p),
("glProgramUniform3iv\0", &glProgramUniform3iv_p),
("glProgramUniform3ui\0", &glProgramUniform3ui_p),
("glProgramUniform3uiv\0", &glProgramUniform3uiv_p),
("glProgramUniform4d\0", &glProgramUniform4d_p),
("glProgramUniform4dv\0", &glProgramUniform4dv_p),
("glProgramUniform4f\0", &glProgramUniform4f_p),
("glProgramUniform4fv\0", &glProgramUniform4fv_p),
("glProgramUniform4i\0", &glProgramUniform4i_p),
("glProgramUniform4iv\0", &glProgramUniform4iv_p),
("glProgramUniform4ui\0", &glProgramUniform4ui_p),
("glProgramUniform4uiv\0", &glProgramUniform4uiv_p),
("glProgramUniformMatrix2dv\0", &glProgramUniformMatrix2dv_p),
("glProgramUniformMatrix2fv\0", &glProgramUniformMatrix2fv_p),
("glProgramUniformMatrix2x3dv\0", &glProgramUniformMatrix2x3dv_p),
("glProgramUniformMatrix2x3fv\0", &glProgramUniformMatrix2x3fv_p),
("glProgramUniformMatrix2x4dv\0", &glProgramUniformMatrix2x4dv_p),
("glProgramUniformMatrix2x4fv\0", &glProgramUniformMatrix2x4fv_p),
("glProgramUniformMatrix3dv\0", &glProgramUniformMatrix3dv_p),
("glProgramUniformMatrix3fv\0", &glProgramUniformMatrix3fv_p),
("glProgramUniformMatrix3x2dv\0", &glProgramUniformMatrix3x2dv_p),
("glProgramUniformMatrix3x2fv\0", &glProgramUniformMatrix3x2fv_p),
("glProgramUniformMatrix3x4dv\0", &glProgramUniformMatrix3x4dv_p),
("glProgramUniformMatrix3x4fv\0", &glProgramUniformMatrix3x4fv_p),
("glProgramUniformMatrix4dv\0", &glProgramUniformMatrix4dv_p),
("glProgramUniformMatrix4fv\0", &glProgramUniformMatrix4fv_p),
("glProgramUniformMatrix4x2dv\0", &glProgramUniformMatrix4x2dv_p),
("glProgramUniformMatrix4x2fv\0", &glProgramUniformMatrix4x2fv_p),
("glProgramUniformMatrix4x3dv\0", &glProgramUniformMatrix4x3dv_p),
("glProgramUniformMatrix4x3fv\0", &glProgramUniformMatrix4x3fv_p),
("glProvokingVertex\0", &glProvokingVertex_p),
("glPushDebugGroup\0", &glPushDebugGroup_p),
("glPushDebugGroupKHR\0", &glPushDebugGroupKHR_p),
("glQueryCounter\0", &glQueryCounter_p),
("glReadBuffer\0", &glReadBuffer_p),
("glReadPixels\0", &glReadPixels_p),
("glReadnPixels\0", &glReadnPixels_p),
("glReleaseShaderCompiler\0", &glReleaseShaderCompiler_p),
("glRenderbufferStorage\0", &glRenderbufferStorage_p),
("glRenderbufferStorageMultisample\0", &glRenderbufferStorageMultisample_p),
("glResumeTransformFeedback\0", &glResumeTransformFeedback_p),
("glSampleCoverage\0", &glSampleCoverage_p),
("glSampleMaski\0", &glSampleMaski_p),
("glSamplerParameterIiv\0", &glSamplerParameterIiv_p),
("glSamplerParameterIuiv\0", &glSamplerParameterIuiv_p),
("glSamplerParameterf\0", &glSamplerParameterf_p),
("glSamplerParameterfv\0", &glSamplerParameterfv_p),
("glSamplerParameteri\0", &glSamplerParameteri_p),
("glSamplerParameteriv\0", &glSamplerParameteriv_p),
("glScissor\0", &glScissor_p),
("glScissorArrayv\0", &glScissorArrayv_p),
("glScissorIndexed\0", &glScissorIndexed_p),
("glScissorIndexedv\0", &glScissorIndexedv_p),
("glShaderBinary\0", &glShaderBinary_p),
("glShaderSource\0", &glShaderSource_p),
("glShaderStorageBlockBinding\0", &glShaderStorageBlockBinding_p),
("glSpecializeShader\0", &glSpecializeShader_p),
("glStencilFunc\0", &glStencilFunc_p),
("glStencilFuncSeparate\0", &glStencilFuncSeparate_p),
("glStencilMask\0", &glStencilMask_p),
("glStencilMaskSeparate\0", &glStencilMaskSeparate_p),
("glStencilOp\0", &glStencilOp_p),
("glStencilOpSeparate\0", &glStencilOpSeparate_p),
("glTexBuffer\0", &glTexBuffer_p),
("glTexBufferRange\0", &glTexBufferRange_p),
("glTexImage1D\0", &glTexImage1D_p),
("glTexImage2D\0", &glTexImage2D_p),
("glTexImage2DMultisample\0", &glTexImage2DMultisample_p),
("glTexImage3D\0", &glTexImage3D_p),
("glTexImage3DMultisample\0", &glTexImage3DMultisample_p),
("glTexParameterIiv\0", &glTexParameterIiv_p),
("glTexParameterIuiv\0", &glTexParameterIuiv_p),
("glTexParameterf\0", &glTexParameterf_p),
("glTexParameterfv\0", &glTexParameterfv_p),
("glTexParameteri\0", &glTexParameteri_p),
("glTexParameteriv\0", &glTexParameteriv_p),
("glTexStorage1D\0", &glTexStorage1D_p),
("glTexStorage2D\0", &glTexStorage2D_p),
("glTexStorage2DMultisample\0", &glTexStorage2DMultisample_p),
("glTexStorage3D\0", &glTexStorage3D_p),
("glTexStorage3DMultisample\0", &glTexStorage3DMultisample_p),
("glTexSubImage1D\0", &glTexSubImage1D_p),
("glTexSubImage2D\0", &glTexSubImage2D_p),
("glTexSubImage3D\0", &glTexSubImage3D_p),
("glTextureBarrier\0", &glTextureBarrier_p),
("glTextureBuffer\0", &glTextureBuffer_p),
("glTextureBufferRange\0", &glTextureBufferRange_p),
("glTextureParameterIiv\0", &glTextureParameterIiv_p),
("glTextureParameterIuiv\0", &glTextureParameterIuiv_p),
("glTextureParameterf\0", &glTextureParameterf_p),
("glTextureParameterfv\0", &glTextureParameterfv_p),
("glTextureParameteri\0", &glTextureParameteri_p),
("glTextureParameteriv\0", &glTextureParameteriv_p),
("glTextureStorage1D\0", &glTextureStorage1D_p),
("glTextureStorage2D\0", &glTextureStorage2D_p),
("glTextureStorage2DMultisample\0", &glTextureStorage2DMultisample_p),
("glTextureStorage3D\0", &glTextureStorage3D_p),
("glTextureStorage3DMultisample\0", &glTextureStorage3DMultisample_p),
("glTextureSubImage1D\0", &glTextureSubImage1D_p),
("glTextureSubImage2D\0", &glTextureSubImage2D_p),
("glTextureSubImage3D\0", &glTextureSubImage3D_p),
("glTextureView\0", &glTextureView_p),
("glTransformFeedbackBufferBase\0", &glTransformFeedbackBufferBase_p),
("glTransformFeedbackBufferRange\0", &glTransformFeedbackBufferRange_p),
("glTransformFeedbackVaryings\0", &glTransformFeedbackVaryings_p),
("glUniform1d\0", &glUniform1d_p),
("glUniform1dv\0", &glUniform1dv_p),
("glUniform1f\0", &glUniform1f_p),
("glUniform1fv\0", &glUniform1fv_p),
("glUniform1i\0", &glUniform1i_p),
("glUniform1iv\0", &glUniform1iv_p),
("glUniform1ui\0", &glUniform1ui_p),
("glUniform1uiv\0", &glUniform1uiv_p),
("glUniform2d\0", &glUniform2d_p),
("glUniform2dv\0", &glUniform2dv_p),
("glUniform2f\0", &glUniform2f_p),
("glUniform2fv\0", &glUniform2fv_p),
("glUniform2i\0", &glUniform2i_p),
("glUniform2iv\0", &glUniform2iv_p),
("glUniform2ui\0", &glUniform2ui_p),
("glUniform2uiv\0", &glUniform2uiv_p),
("glUniform3d\0", &glUniform3d_p),
("glUniform3dv\0", &glUniform3dv_p),
("glUniform3f\0", &glUniform3f_p),
("glUniform3fv\0", &glUniform3fv_p),
("glUniform3i\0", &glUniform3i_p),
("glUniform3iv\0", &glUniform3iv_p),
("glUniform3ui\0", &glUniform3ui_p),
("glUniform3uiv\0", &glUniform3uiv_p),
("glUniform4d\0", &glUniform4d_p),
("glUniform4dv\0", &glUniform4dv_p),
("glUniform4f\0", &glUniform4f_p),
("glUniform4fv\0", &glUniform4fv_p),
("glUniform4i\0", &glUniform4i_p),
("glUniform4iv\0", &glUniform4iv_p),
("glUniform4ui\0", &glUniform4ui_p),
("glUniform4uiv\0", &glUniform4uiv_p),
("glUniformBlockBinding\0", &glUniformBlockBinding_p),
("glUniformMatrix2dv\0", &glUniformMatrix2dv_p),
("glUniformMatrix2fv\0", &glUniformMatrix2fv_p),
("glUniformMatrix2x3dv\0", &glUniformMatrix2x3dv_p),
("glUniformMatrix2x3fv\0", &glUniformMatrix2x3fv_p),
("glUniformMatrix2x4dv\0", &glUniformMatrix2x4dv_p),
("glUniformMatrix2x4fv\0", &glUniformMatrix2x4fv_p),
("glUniformMatrix3dv\0", &glUniformMatrix3dv_p),
("glUniformMatrix3fv\0", &glUniformMatrix3fv_p),
("glUniformMatrix3x2dv\0", &glUniformMatrix3x2dv_p),
("glUniformMatrix3x2fv\0", &glUniformMatrix3x2fv_p),
("glUniformMatrix3x4dv\0", &glUniformMatrix3x4dv_p),
("glUniformMatrix3x4fv\0", &glUniformMatrix3x4fv_p),
("glUniformMatrix4dv\0", &glUniformMatrix4dv_p),
("glUniformMatrix4fv\0", &glUniformMatrix4fv_p),
("glUniformMatrix4x2dv\0", &glUniformMatrix4x2dv_p),
("glUniformMatrix4x2fv\0", &glUniformMatrix4x2fv_p),
("glUniformMatrix4x3dv\0", &glUniformMatrix4x3dv_p),
("glUniformMatrix4x3fv\0", &glUniformMatrix4x3fv_p),
("glUniformSubroutinesuiv\0", &glUniformSubroutinesuiv_p),
("glUnmapBuffer\0", &glUnmapBuffer_p),
("glUnmapNamedBuffer\0", &glUnmapNamedBuffer_p),
("glUseProgram\0", &glUseProgram_p),
("glUseProgramStages\0", &glUseProgramStages_p),
("glValidateProgram\0", &glValidateProgram_p),
("glValidateProgramPipeline\0", &glValidateProgramPipeline_p),
("glVertexArrayAttribBinding\0", &glVertexArrayAttribBinding_p),
("glVertexArrayAttribFormat\0", &glVertexArrayAttribFormat_p),
("glVertexArrayAttribIFormat\0", &glVertexArrayAttribIFormat_p),
("glVertexArrayAttribLFormat\0", &glVertexArrayAttribLFormat_p),
("glVertexArrayBindingDivisor\0", &glVertexArrayBindingDivisor_p),
("glVertexArrayElementBuffer\0", &glVertexArrayElementBuffer_p),
("glVertexArrayVertexBuffer\0", &glVertexArrayVertexBuffer_p),
("glVertexArrayVertexBuffers\0", &glVertexArrayVertexBuffers_p),
("glVertexAttrib1d\0", &glVertexAttrib1d_p),
("glVertexAttrib1dv\0", &glVertexAttrib1dv_p),
("glVertexAttrib1f\0", &glVertexAttrib1f_p),
("glVertexAttrib1fv\0", &glVertexAttrib1fv_p),
("glVertexAttrib1s\0", &glVertexAttrib1s_p),
("glVertexAttrib1sv\0", &glVertexAttrib1sv_p),
("glVertexAttrib2d\0", &glVertexAttrib2d_p),
("glVertexAttrib2dv\0", &glVertexAttrib2dv_p),
("glVertexAttrib2f\0", &glVertexAttrib2f_p),
("glVertexAttrib2fv\0", &glVertexAttrib2fv_p),
("glVertexAttrib2s\0", &glVertexAttrib2s_p),
("glVertexAttrib2sv\0", &glVertexAttrib2sv_p),
("glVertexAttrib3d\0", &glVertexAttrib3d_p),
("glVertexAttrib3dv\0", &glVertexAttrib3dv_p),
("glVertexAttrib3f\0", &glVertexAttrib3f_p),
("glVertexAttrib3fv\0", &glVertexAttrib3fv_p),
("glVertexAttrib3s\0", &glVertexAttrib3s_p),
("glVertexAttrib3sv\0", &glVertexAttrib3sv_p),
("glVertexAttrib4Nbv\0", &glVertexAttrib4Nbv_p),
("glVertexAttrib4Niv\0", &glVertexAttrib4Niv_p),
("glVertexAttrib4Nsv\0", &glVertexAttrib4Nsv_p),
("glVertexAttrib4Nub\0", &glVertexAttrib4Nub_p),
("glVertexAttrib4Nubv\0", &glVertexAttrib4Nubv_p),
("glVertexAttrib4Nuiv\0", &glVertexAttrib4Nuiv_p),
("glVertexAttrib4Nusv\0", &glVertexAttrib4Nusv_p),
("glVertexAttrib4bv\0", &glVertexAttrib4bv_p),
("glVertexAttrib4d\0", &glVertexAttrib4d_p),
("glVertexAttrib4dv\0", &glVertexAttrib4dv_p),
("glVertexAttrib4f\0", &glVertexAttrib4f_p),
("glVertexAttrib4fv\0", &glVertexAttrib4fv_p),
("glVertexAttrib4iv\0", &glVertexAttrib4iv_p),
("glVertexAttrib4s\0", &glVertexAttrib4s_p),
("glVertexAttrib4sv\0", &glVertexAttrib4sv_p),
("glVertexAttrib4ubv\0", &glVertexAttrib4ubv_p),
("glVertexAttrib4uiv\0", &glVertexAttrib4uiv_p),
("glVertexAttrib4usv\0", &glVertexAttrib4usv_p),
("glVertexAttribBinding\0", &glVertexAttribBinding_p),
("glVertexAttribDivisor\0", &glVertexAttribDivisor_p),
("glVertexAttribDivisorARB\0", &glVertexAttribDivisorARB_p),
("glVertexAttribFormat\0", &glVertexAttribFormat_p),
("glVertexAttribI1i\0", &glVertexAttribI1i_p),
("glVertexAttribI1iv\0", &glVertexAttribI1iv_p),
("glVertexAttribI1ui\0", &glVertexAttribI1ui_p),
("glVertexAttribI1uiv\0", &glVertexAttribI1uiv_p),
("glVertexAttribI2i\0", &glVertexAttribI2i_p),
("glVertexAttribI2iv\0", &glVertexAttribI2iv_p),
("glVertexAttribI2ui\0", &glVertexAttribI2ui_p),
("glVertexAttribI2uiv\0", &glVertexAttribI2uiv_p),
("glVertexAttribI3i\0", &glVertexAttribI3i_p),
("glVertexAttribI3iv\0", &glVertexAttribI3iv_p),
("glVertexAttribI3ui\0", &glVertexAttribI3ui_p),
("glVertexAttribI3uiv\0", &glVertexAttribI3uiv_p),
("glVertexAttribI4bv\0", &glVertexAttribI4bv_p),
("glVertexAttribI4i\0", &glVertexAttribI4i_p),
("glVertexAttribI4iv\0", &glVertexAttribI4iv_p),
("glVertexAttribI4sv\0", &glVertexAttribI4sv_p),
("glVertexAttribI4ubv\0", &glVertexAttribI4ubv_p),
("glVertexAttribI4ui\0", &glVertexAttribI4ui_p),
("glVertexAttribI4uiv\0", &glVertexAttribI4uiv_p),
("glVertexAttribI4usv\0", &glVertexAttribI4usv_p),
("glVertexAttribIFormat\0", &glVertexAttribIFormat_p),
("glVertexAttribIPointer\0", &glVertexAttribIPointer_p),
("glVertexAttribL1d\0", &glVertexAttribL1d_p),
("glVertexAttribL1dv\0", &glVertexAttribL1dv_p),
("glVertexAttribL2d\0", &glVertexAttribL2d_p),
("glVertexAttribL2dv\0", &glVertexAttribL2dv_p),
("glVertexAttribL3d\0", &glVertexAttribL3d_p),
("glVertexAttribL3dv\0", &glVertexAttribL3dv_p),
("glVertexAttribL4d\0", &glVertexAttribL4d_p),
("glVertexAttribL4dv\0", &glVertexAttribL4dv_p),
("glVertexAttribLFormat\0", &glVertexAttribLFormat_p),
("glVertexAttribLPointer\0", &glVertexAttribLPointer_p),
("glVertexAttribP1ui\0", &glVertexAttribP1ui_p),
("glVertexAttribP1uiv\0", &glVertexAttribP1uiv_p),
("glVertexAttribP2ui\0", &glVertexAttribP2ui_p),
("glVertexAttribP2uiv\0", &glVertexAttribP2uiv_p),
("glVertexAttribP3ui\0", &glVertexAttribP3ui_p),
("glVertexAttribP3uiv\0", &glVertexAttribP3uiv_p),
("glVertexAttribP4ui\0", &glVertexAttribP4ui_p),
("glVertexAttribP4uiv\0", &glVertexAttribP4uiv_p),
("glVertexAttribPointer\0", &glVertexAttribPointer_p),
("glVertexBindingDivisor\0", &glVertexBindingDivisor_p),
("glViewport\0", &glViewport_p),
("glViewportArrayv\0", &glViewportArrayv_p),
("glViewportIndexedf\0", &glViewportIndexedf_p),
("glViewportIndexedfv\0", &glViewportIndexedfv_p),
("glWaitSync\0", &glWaitSync_p),
];
      let mut load_failures = Vec::new();
      for (command_name, command_p) in command_info.iter() {
        let addr: usize = match load_fn(command_name.as_ptr()) as usize {
          0 | 1 | 2 | 3 | usize::MAX => {
            load_failures.push(&command_name[..command_name.len()-1]);
            0
          }
          other => other
        };
        command_p.store(addr, core::sync::atomic::Ordering::Release);
      }
      if load_failures.is_empty() {
        Ok( () )
      } else {
        Err( load_failures )
      }
    }
    
